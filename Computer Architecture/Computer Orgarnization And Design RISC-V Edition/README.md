<h1>:green_book: <Computer Orgarnization And Design RISC-V Edition> 정리</h1>

<a href="#1">:pencil2: Chapter1. 컴퓨터 추상화 및 관련 기술</a>
- 컴퓨터 구조 분야의 일곱 가지 위대한 아이디어
- 프로그램 밑의 세계
- 케이스를 열고
- 프로세서와 메모리 생산 기술
- 성능
- 전력 장벽
- 현저한 변화: 단일프로세서에서 멀티프로세서로의 변화
- 오류 및 함정

 <a href="#2">:pencil2: Chapter2. 명령어: 컴퓨터 언어</a>
 - 부호있는 수와 부호없는 수
 - 문자와 문자열

<h2><a id="1">:pencil2: Chapter1. 컴퓨터 추상화 및 관련 기술</a></h2>

**:pushpin: 컴퓨터 구조 분야의 일곱 가지 위대한 아이디어**

- 설계를 단순화 하는 추상화: 하위 수준의 상세한 사항을 안 보이게 함으로써 상위 수준 모델을 단순화함.<br>
- 자주 생기는 일을 빠르게: 드물게 생기는 일을 최적화하는 것보다 성능 개선에 도움이 됨.<br>
- 병렬성을 통한 성능 개선<br>
- 파이프라이닝을 통한 성능 개선<br>
- 예측을 통한 성능 개선<br>
- 메모리 계층 구조: 최상위 계층에는 가장 빠르고, 가장 작고, 비트당 가격이 제일 비싼 메모리를 사용하고, 최하위 계층에는 느리지만 크고 비트당 가격이 제일 싼 메모리를 사용함.<br>
- 여유분을 이용한 신용도 개선: 모든 물리 소자는 장애가 발생할 수 있으므로, 장애를 감지하고 장애가 난 소자를 대치할 수 있도록 여유분을 준비하면 컴퓨터의 신용도를 개선할 수 있음.<br>

**:pushpin: 프로그램 밑의 세계**

소프트웨어들은 계층적으로 구성됨. 응용 프로그램이 가장 바깥쪽에 위치하며, 여러 가지 시스템 소프트웨어가 하드웨어와 응용 소프트웨어 사이에 존재함.<br>
시스템 소프트웨어는 여러가지가 있으나 대표적으로 운영체제와 컴파일러가 있음.<br>
운영체제는 사용자 프로그램과 하드웨어 간의 인터페이스 역할을 하면서 각종 서비스와 감독 기능을 제공함.<br>
기본적 입출력 작업의 처리, 보조기억장치 및 메모리 할당, 컴퓨터를 동시에 사용하는 여러 응용들 간의 컴퓨터 공유 방법 제공 등 기능이 있음.<br>
오늘날 사용되고 있는 운영체제의 예로는 Windows, Linux, iOS, Android 등이 있음.<br>
컴파일러는 C, C++, Java, Visual Basic 같은 상위 수준 언어로 작성된 프로그램을 하드웨어가 실행할 수 있는 명령어로 번역하는 일을 함.<br>

**상위 수준 언어에서 기계어까지**

기계어는 기수 2인 숫자, 즉 이진수라고 생각함.<br>
각 문자를 이진 자릿수 또는 비트라고 부름.<br>
명령어(instruction)는 컴퓨터 하드웨어가 이해하고 실행하는 명령임.<br>
어셈블러는 기호로 된 명령어(어셈블리 언어)를 이진수 프로그램으로 번역하는 프로그램임.<br>
예를 들어 add A, B라고 쓰면 어셈블러가 이것을 1001010100101110으로 바꿈.<br>
기계가 이해하는 언어는 기계어라고 부름.<br>
어셈블리 언어는 컴퓨터가 실행할 명령어를 한 줄에 하나씩 써야하기 때문에 프로그래머에게 기계식 사고 방식을 강요함.<br>
상위 수준 언어에서 A + B가 있으면 컴파일러는 이것을 번역해서 add A, B와 같은 어셈블리 언어 문장으로 바꿈.<br>

**:pushpin: 케이스를 열고**
 
 모든 컴퓨터의 하드웨어는 데이터 입력, 출력, 처리, 저장 네 가지 기본 기능을 수행함.<br>
 입력장치는 키보드나 마우스와 같이 컴퓨터에 정보를 공급하는 장치임.<br>
 출력장치는 연산의 결과를 사용자나 다른 컴퓨터에 보내주는 장치임.<br>
 컴퓨터의 고전적 구성 요소 다섯 가지는 입력, 출력, 메모리, 데이터패스, 제어 유닛임. 데이터패스와 제어 유닛을 합쳐서 프로세서라고 부르기도 함.<br>
 프로세서는 메모리에서 명령어와 데이터를 읽음.<br>
 입력장치는 메모리에 데이터를 쓰고, 출력장치는 메모리에서 데이터를 읽음.<br>
 제어 유닛은 데이터패스, 메모리, 입력장치, 출력장치의 동작을 결정하는 신호를 내보냄.<br>
 
 **디스플레이**<br>
 
 개인 휴대용 기기들은 얇고 전력 소모가 적은 LCD(Liquid crystal display)를 사용함.<br>
 LCD는 스스로 빛을 내는 대신 통과하는 빛을 제어함.<br>
 전형적인 LCD에는 액체 상태의 막대 모양 분자가 있어서 디스플레이에 들어오는 빛을 굴절시킴.<br>
 빛은 보통 디스플레이 뒤쪽의 광원에서 보내지며, 이보다 흔하지는 않지만 반사광을 이용하는 경우도 있음.<br>
 이 막대들이 보통 때는 꼬인 나선 모양으로 배열되어서 빛을 굴절시키다가 전류를 흘리면 똑바로 퍼져서 빛을 통과시킴.<br>
 90도로 편광된 두 스크린 사이에 액정 물질을 넣기 때문에 빛이 꺽이지 않는 한 통과할 수 없음.<br>
 오늘날 대부분의 LCD는 매 화소 위치마다 작은 트랜지스터를 배치하여 전류를 정밀하게 제어하는 능동 행렬을 사용하므로 더욱 선명한 이미지를 제공함.<br>
 매 화소마다 R-G-B 마스크가 있어서 각 원색의 강도를 결정함. 따라서 컬러 능등 행령 LCD에는 화소마다 3개의 트랜지스터 스위치가 있음.<br>
 화소는 영상을 구성하는 제일 작은 원소를 뜻함.<br>
 각 화상은 화소의 행렬로 구성되며, 이것은 비트맵이라 부르는 비트들의 행렬로 표현됨.<br>
 디스플레이 행렬은 스크린의 크기와 해상도에 따라 1024 * 768에서 2048 * 1536개의 화소로 구성됨.<br>
 컬러 디스플레이는 빛의 삼원색(빨강, 파랑, 초록) 각각마다 8비트씩, 모두 24비트를 사용하여 수백만 가지의 색을 표시할 수 있음.<br>
 그래픽을 지원하는 하드웨어의 중심이 되는 것은 비트맵을 기억하는 프레임 버퍼라고 하는 부분임.<br>
 그래픽 하드웨어는 스크린에 표시될 화상을 프레임 버퍼에 저장하였다가, 기억된 각 화소의 비트 패턴을 재생 속도에 맞추어 그래픽 디스플레이로 보냄.<br>
 
 **터치스크린**<br>
 
 태블릿과 스마트폰은 키보드와 마우스 대신 터치를 감지하는 디스플레이를 사용하고 있음.<br>
 터치스크린을 구현하는 방법 중 하나는 정전용량 감지 기법임.<br>
 유리 같은 절연체 위에 투명한 도체를 코팅하면, 사람이 손을 댔을 때 손에 전기가 통하기 때문에 스크린의 정전기장이 찌그러지면서 정전용량이 변하게 됨.<br>
 
 **상자를 열고**<br>
 
 집적회로는 칩이라고도 부름. 수천만 개의 트랜지스터가 결합된 부품임.<br>
 CPU는 프로세서라고도 부름. 데이터패스와 제어 유닛으로 구성된 컴퓨터의 핵심 부분임. 숫자를 더하거나 검사하고, 입출력장치에 신호를 보내 활성화하는 일을 함.<br>
 데이터패스는 산술 연산을 수행하는 프로세서의 구성 요소임.<br>
 제어 유닛은 프로그램의 명령어에 따라 데이터패스, 메모리, 입출력장치에 지시를 하는 프로세서 구성 요소임.<br>
 메모리는 실행 중인 프로그램과 프로그램 실행에 필요한 데이터의 저장소임. 메모리는 DRAM 칩으로 구성되어 있음.<br>
 DRAM(Dynamic Random Access Memory)은 집적회로로 만든 메모리의 일종임. 어떤 위치든지 임의로 접근할 수 있음. 접근 시간은 50ns정도임.<br>
 DRAM 여러 개를 한데 묶어서 프로그램의 명령어와 데이터를 기억하는데 사용함.<br>
 DRAM에서 RAM은 자기 테이프 같은 순차 접근 메모리와는 반대로 메모리의 어떤 부분을 읽든지 같은 시간이 걸린다는 것을 의미함.<br>
 프로세서 내부에는 또 다른 종류의 메모리가 있는데 이것을 캐시 메모리라고함.<br>
 캐시 메모리는 DRAM의 버퍼 역할을 하는 작고 빠른 메모리임.<br>
 캐시는 SRAM(Static Random Access Memory)이라는 메모리 기술을 이용함. SRAM은 DRAM보다 빠르지만 집적도가 낮아서 가격이 비쌈.<br>
 SRAM과 DRAM은 메모리 계층구조의 두 계층을 구성함.<br>
 소프트웨어는 하드웨어와 어휘를 통해 통신함.<br>
 어휘를 구성하는 단어들을 명령어라고 하고, 어휘 자체는 명령어 지밥 구조(Instruction Set Architecture) 또는 단순히 구조라고 함.
 응용 프로그래머에게 제공되는 기본 명령어 집합과 운영체제 인터페이스를 합쳐서 ABI(Application Binary Interface)라고 함.<br>
 
 **데이터의 안전한 저장소**<br>
 
메인 메모리: 휘발성 메모리라고도 함. DRAM과 같이 전원이 공급되는 동안만 데이터를 기억하는 기억장치임.<br>
보조기억장치: 비휘발성 메모리라고도 함. 전원 공급이 끊어져도 데이터를 계속 기억하는 기억장치로, 다음 실행 때까지 프로그램을 저장하는 데 사용됨. 보조기억장치는 메모리 계층구조에서 메인 메모리보다 한 단계 아래 계층에 해당함.<br>
 DRAM이 메인 메모리의 주종을 이루고 있으며, 자기 디스크는 그 전부터 보조기억장치의 주종이 되었음.<br>
 개인 휴대용 기기는 크기와 모양의 제약 때문에 자기 디스크 대신 비휘발성 반도체 메모리인 플래시 메모리를 사용함.<br>
 플래시 메모리는 DRAM보다 느리지만, DRAM보다 훨씬 싸고 비휘발성이라는 장점이 있음.<br>
 디스크보다 비트당 단가는 비싸지만, 작고 튼튼하며 전력 소모가 적고 훨씬 소용량으로 생산될 수 있음.<br>
 그래서 PMD(Persistent Memory Device, 영구 저장이 가능한 비휘발성 메모리를 의미)의 표준 보조기억장치로 사용됨. 하지만 DRAM이나 자기 디스크와 달리 플래시 메모리는 10만번 내지 100만번 쓰기를 한 후에는 못 쓰게 됨.<br>
 
 **컴퓨터 간의 통신**<br>
 
 네트워크로 컴퓨터를 연결했을 때의 장점은 통신, 자원 공유, 원격 접근 등이 있음.<br>
 네트워크 중에서 가장 널리 알려진 것은 이더넷(Ethernet)임.<br>
 이더넷으로 연결할 수 있는 거리는 대략 1km 정도이고, 초당 100Gb를 전송할 수 있음.<br>
 한 건물의 같은 층에 있는 컴퓨터들을 연결하는데 유용한 근거리 네트워크(Local Area Network, LAN)의 일종임.<br>
 라우터 서비스와 보안을 제공하는 스위치를 사용하면 LAN들을 서로 연결할 수 있음.<br>
 원거리 네트워크(Wide Area Network, WAN)는 여러 대륙을 연결하여 웹(world Wide Web)을 지원하고 있는 인터넷의 근간을 이룸.<br>

**:pushpin: 프로세서와 메모리 생산 기술**
 
 집적회로 칩의 생산은 모래의 구성 성분인 실리콘에서부터 출발함.<br>
 실리콘은 전기가 통하기는 하는데 완전 잘 통하는 것은 아니어서 반도체임.<br>
 특수한 화학적 처리를 거쳐 불순물을 첨가하면 실리콘의 작은 부분을 세 가지 중 하나로 바꿀 수 있음.<br>
 전기 양도체(초소형 구리나 알루미늄 전선), 전기 절연체(플라스틱 피복이나 유리 등), 조건에 따라 도체가 되기도 하고 절연체가 되기도 하는 물질(스위치)<br>
 공정은 실리콘 결정 괴(silicon crystal ingot)에서부터 시작됨.<br>
 실리콘 괴의 직경은 8~12인치, 길이는 12~24인치 정도임.<br>
 이 덩어리를 0.1인치 이하의 두께로 얇게 잘라 웨이퍼를 만듦.<br>
 웨이퍼는 화학 물질을 첨가하여 부분 부분을 트랜지스터, 도체, 절연체로 바꾸는 일련의 공정을 거치게 됨.<br>
 빈 웨이퍼에는 패턴이 새겨지는데, 이를 웨이퍼 검사기로 검사해서 불량 부분에 표시함.<br>
 웨이퍼 자체에 미세한 흠집이 있었거나 여러 공정 중에 어느 한 부분에서라도 흠집이 생기면 웨이퍼의 그 부분은 못 쓰게 되는데, 이러한 결함 때문에 완벽한 웨이퍼를 만드는 건 거의 불가능함.<br>
 불완전성에 대처하기 위해 한 웨이퍼에 독립적인 컴포넌트를 여러 개 만들고, 웨이퍼를 컴포넌트별로 자르는데 이것을 다이 또는 칩이라고 함.<br>
 여러 조각으로 나누면 웨이퍼에 결함이 생겼을 때 웨이퍼 전체를 버리는 대신 해당 다이만 버리면 됨. 이 개념을 수율로 계량화 할 수 있음.<br>
 한 웨이퍼에서 20개의 다이가 만들어지고 그 중 17개만이 검사를 통과하면 수율은 85%임.<br>
 다이 크기가 커지면 웨이퍼에 넣을 수 있는 다이가 적어지고 수율이 떨어지므로 집적회로 가격이 급속히 증가함.<br>
 차세대 프로세스를 이용해서 트랜지스터와 연결선의 크기를 줄임으로써 큰 다이를 축소시켜 원가 절감을 꾀하기도 함.<br>
 이렇게 하면 수율과 웨이퍼당 다이 개수가 개선됨.<br>
 다이가 10 nm 공정을 사용하고 있다는 말은 가장 작은 트랜지스터의 크기가 10nm라는 뜻임.<br>
 하지만 트랜지스터는 실제 최소 배선폭보다 더 작은 것이 보통임.<br>
 최소 배선폭이란 최종 생산된 트랜지스터의 크기가 아니라 마스크에 그려진 크기를 뜻하는 것임.<br>
 결함이 없는 다이는 패키지의 입출력 핀과 연결하는데 이 과정을 본딩이라고 함.<br>
 납품하기 전에는 다시 한번 검사를 거침.<br>
 
 **집적회로 가격**<br>
 
 다이 원가 = 웨이퍼당 가격 / (웨이퍼당 다이의 수 * 수율)<br>
 웨이퍼당 다이의 수 = 웨이퍼의 면적 / 다이의 면적<br>
 수율 = 1 / (( 1 + (면적당 결함의 수 * 다이 면적 ) ) ^ n)<br>
 n은 공정의 수인데, 공정이 많을 수록 수율은 떨어짐.<br>
 
**:pushpin: 성능**
 
 성능x = 1 / 실행시간x<br>
 성능x > 성능y는 1 / 실행시간x > 1 / 실행시간y랑 같으므로 실행시간y > 실행시간x와 같은 말임.<br>
 X가 Y보다 n배 빠르다면 성능x / 성능y = 실행시간y / 실행시간x = n임.<br>
 
 **성능의 측정**<br>
 
 보통 성능을 측정하기 위해 사용하는 시간은 벽시계 시간, 응답시간, 경과시간 등이 있음.<br>
 이것은 한 작업을 끝내는 데 필요한 전체 시간을 뜻하는 것으로 디스크 접근, 메모리 접근, 입출력 작업, 운영체제 오버헤드 등 모든 시간을 다 더한 것임.<br>
 컴퓨터를 공유하는 경우, 프로세서 하나가 여러 프로그램을 동시에 실행하는 경우가 많이 있음.<br>
 그러므로 경과시간과 구분해서 프로세서가 순수하게 이 프로그램을 실행하기 위해 소비한 시간을 계산할 필요가 있음.<br>
 이 시간을 CPU 실행시간 또는 CPU 시간이라고 함.<br>
 CPU 시간은 실제로 사용자 프로그램 실행에 소요된 사용자 CPU 시간과 운영체제가 이 프로그램을 위한 작업을 수행하기 위해 소비한 시스템 CPU 시간으로 다시 나눌 수 있음.<br>
 그러나 운영체제의 각 작업이 어떤 프로그램을 위해서 수행되고 있는가를 명확히 가려내는 것이 어렵고 운영체제 간의 기능 차이도 있기 때문에 시스템 CPU 시간과 사용자 CPU 시간을 정확히 구하는 것은 어려움.<br>
 다른 부하가 없는 시스템에서의 경과시간으로 계산한 것을 시스템 성능, 사용자 CPU 시간으로 계산한 것을 CPU 성능이라고 부름.<br>
 거의 모든 컴퓨터는 하드웨어 이벤트가 발생하는 시점을 결정하는 클럭을 이용하여 만들어짐.<br>
 이 클럭의 시간 간격을 클럭 사이클이라 함.<br>
 클럭 주기는 한 클럭 사이클에 걸리는 시간(250ps 등)이나 클럭 속도(4 GHz 등)로 표시함.<br>
 클럭 속도는 클럭 주기의 역수임.<br>
 
 **CPU 성능과 성능 인자**<br>
 
 프로그램의 CPU 실행 시간 = 프로그램의 CPU 클럭 사이클 수 * 클럭 사이클 시간<br>
 프로그램의 CPU 실행 시간 = 프로그램의 CPU 클럭 사이클 수 / 클럭 속도<br>
 
 **명령어 성능**<br>
 
 CPU 클럭 사이클 수 = 명령어 수 * 명령어당 평균 클럭 사이클 수<br>
 명령어당 클럭 사이클 수(clock cycles per instruction)은 CPI로 줄여 쓰기도 함.<br>
 명령어마다 실행시간이 다르므로 CPI는 프로그램이 실행한 모든 명령어에 대해 평균한 값을 사용함.<br>
 명령어 집합 구조가 같으면 프로그램에 필요한 명령어 수가 같으므로, CPI는 서로 다른 구현을 비교하는 한 가지 기준이 될 수 있음.<br>
 
 **고전적인 CPU 성능식**<br>
 
 CPU 시간 = 명령어 개수 * CPI * 클럭 사이클 시간<br>
 CPU 시간 = 명령어 개수 * CPI / 클럭 속도<br>
CPU 실행시간은 실제 프로그램을 실행시켜서 얻을 수 있고, 클럭 사이클 시간은 보통 컴퓨터의 하드웨어 매뉴얼에 기록되어 있음.<br>
 그러나 명령어 개수와 CPI는 구하기가 어려움.<br>
 물론 클럭 속도와 CPU 실행시간을 알 때, 명령어 개수나 CPI 중 하나를 알면 다른 하나는 계산으로 구할 수 있음.<br>
 명령어 개수는 실행 과정을 추적하는 소프트웨어 도구나 컴퓨터 구조의 시뮬레이터를 이용해서 측정할 수 있음.<br>
 그 외에 하드에어 카운터를 사용하면 실행 명령어 수나 평균 CPI, 심지어는 성능 저하의 원인까지 찾아낼 수 있음.<br>
 명령어 개수는 구조에 따라서 결정될 뿐 구현 방법과는 상관이 없으므로 자세한 구현 내용은 몰라도 구할 수 있음.<br>
 그러나 CPI는 프로그램 실행에 사용되는 명령어 배합뿐 아니라 메모리 시스템과 프로세서 구조를 포함하는 여러 가지 컴퓨터 세부 설계에 따라 달라짐.<br>
 따라서 CPI는 명령어 집합이 같더라도 구현 방식에 따라서 달라질 뿐 아니라 응용 프로그램에 따라서도 달라짐.<br>
 CPU 성능식의 인자에 영향을 미치는 요소는 알고리즘, 프로그래밍 언어, 컴파일러, 명령어 집합 구조 등이 있음.<br>
 CPI의 역수인 IPC(Instructions per clock cycle, 클럭 사이클당 명령어 수)도 사용함.<br>
 전통적으로 클럭 사이클 시간은 고정값을 사용해 왔지만, 오늘날의 프로세서는 에너지를 절약하거나 일시적으로 성능을 높이기 위해서 클럭 속도를 변경시키기도 함.<br>
 따라서 프로그램에 대한 평균 클럭 속도를 사용할 필요가 있음.<br>
 
**:pushpin: 전력 장벽**
 
 지난 36년간 클럭 속도와 소비 전력은 오랫동안 빠르게 증가하다가 최근에 주춤해지거나 감소함.<br>
 속도와 전력이 같이 증가하는 이유는 둘이 서로 연관되어 있기 때문임.<br>
 최근에 성장이 정체된 이유는 상용 마이크로프로세서의 냉각 문제 때문에 실제로 사용할 수 있는 전력이 한계에 도달했기 때문임.<br>
 집적 회로의 주된 기술인 CMOS(Complementary Metal Oxide Semiconductor)가 에너지를 소비하는 주 원인은 동적 에너지임.<br>
 동적 에너지란 트랜지스터가 0에서 1로 혹은 그 반대로 스위칭하는 동안에 소비되는 에너지를 말함.<br>
 동적 에너지는 옹량성 부하 * 전압^2로 결정됨.<br>
 이 식은 0 -> 1 -> 0 또는 1 -> 0 -> 1로 논리값이 두 번 바뀔 때 소모하는 에너지임.
 한 번 바뀔 때 소모되는 에너지는 (1/2) * 용량성 부하 * 전압^2임.<br>
 트랜지스터 하나가 소비하는 전력은 (1/2) * 용량성 부하 * 전압^2 * 스위칭빈도임.<br>
 스위칭 빈도는 클럭 속도의 함수임.<br>
 트랜지스터의 용량성 부하는 출력 단자에 연결된 트랜지스터의 개수(팬아웃)와 공정 기술의 함수임.<br>
 공정 기술은 도선과 트랜지스터의 용량을 결정함.<br>
 전력이 고작 30배 증가하는 동안 클럭 속도는 1000배 빨라질 수 있었던 이유는 새로운 공정이 나올 때마다 전압이 낮아졌고, 전력은 전압의 제곱에 비례하기 떄문임.<br>
 공정 기술 세대가 바뀔 때마다 대략 15%씩 전압이 줄어들었고, 20년 동안 전압은 5V에서 1V로 줄어들었는데, 이것이 전력이 고작 30배밖에 증가하지 않은 이유임.<br>
 오늘날의 문제는 전압을 더 이상 낮추면 트랜지스터 누설 전류가 너무 커진다는 것인데, 이는 꽉 잠기지 않는 수도꼭지의 문제와 같음.<br>
 서버 칩에서 현재 이미 40%의 전력이 누설 전류에 의해 소모되고 있음.<br>
 전력 문제 해결을 위해 설계자들은 이미 냉각이 잘 되도록 큰 장치를 부착해놓았으며, 클럭 사이클 단위로 사용하지 않는 부분을 꺼 버리는 방법을 쓰고 있음.<br>
 
**:pushpin: 현저한 변화: 단일프로세서에서 멀티프로세서로의 변화**

데스크탑 마이크로프로세서의 프로그램 응답시간 개선 속도는 2002년부터는 매년 1.5배에서 1.03배로 둔화됨.<br>
2006년에 모든 데스크탑과 서버 회사는 단일프로세서에서 한 프로그램의 응답 시간을 줄여 나가는 대신 마이크로프로세서 칩 하나에 여러 개의 프로세서를 집적하는 방식으로 전환함.<br>
이 방법은 응답시간보다 처리량 개선에 더 효과가 있음.<br>
프로세서와 마이크로프로세서 두 용어 사이의 혼란을 줄이기 위해 프로세서를 코어라고 부르고, 마이크로프로세서를 멀티코어 마이크로프로세서라고 부름.<br>

**병렬성**<br>
파이프라이닝은 명령어의 실행을 중첩시켜서 프로그램을 실행시키는 기술로 명령어 수준 병렬성의 한 예시임.<br>
파이프라이닝에서는 하드웨어의 병렬적인 특성이 드러나지 않아서 프로그래머와 컴파일러는 하드웨어가 명령어를 순차적으로 실행시키는 것으로 여길 수 있음.<br>
명시적 병렬 프로그램을 작성하는 것이 어려운 첫 번째 이유는 병렬 프로그래밍은 정의상 성능을 중시하는 프로그래밍이고, 이것이 프로그래밍의 어려움을 가중시키기 때문임.<br>
둘째 이유는 병렬 하드웨어에서 빠르게 실행된다는 것은 각 프로세서가 대략 비슷한 양의 일을 동시에 실행하도록 응용을 분할해야 하고, 병렬성으로부터 얻을 수 있는 잠재적인 성능의 이득을 침해하지 않도록 분할된 일을 스케줄링하고 조정하는 오버헤드가 작아야 함을 의미하기 떄문임.<br>
다른 모든 부분들이 끝나기 전에는 쓸 수 없는 부분이 있다면 이 또한 성능 미진의 이유가 될 수 있음. 통신 및 동기화 오버헤드를 줄이기 위해 각별한 주의가 요구됨.<br>

**:pushpin: 오류 및 함정**

**함정: 컴퓨터의 한 부분만 개선하고 그 개선된 양에 비례해서 전체 성능이 좋아지리라고 기대하는 것.**<br>

자주 생기는 일을 빠르게라는 아이디어는 성능을 개선하려는 노력이 얼마나 효과가 있는지는 그 사건이 얼마나 많이 발생하는지와 관련이 있다는 것임.<br>
개선 후의 프로그램 실행시간은 Amdahl의 법칙으로 표현할 수 있음.<br>
개선 후 실행시간 = 개선에 의해 영향을 받는 실행시간 / 개선의 크기 + 영향을 받지 않는 실행시간<br>

**오류: 이용률이 낮은 컴퓨터는 전력 소모가 작다.**<br>

서버는 작업부하가 가변적이기 때문에 이용률이 낮을 때의 전력 효율이 중요함.<br>
서버는 부하가 작을 때에도 최대 전력의 상당 부분을 사용하기 있기 때문임.<br>

**오류: 성능에 초점을 둔 설계와 에너지 효율에 초점을 둔 설계는 서로 무관하다.**<br>

에너지는 전력을 시간에 대해 적분한 것이므로, 어떤 하드웨어나 소프트웨어 최적화 기술이 에너지를 더 소비하더라도 실행시간을 줄여서 전체 에너지를 절약하기도 함.<br>
그 이유 중 하나는 프로그램이 실행되는 동안 최적화와 관련 없는 다른 부분이 에너지를 소모하기 때문에 실행시간이 짧아지면 시스템의 전체 에너지가 절약됨.<br>

**함정: 성능식의 일부분을 성능의 척도로 사용하는 것.**<br>

클럭 속도나 명령어 개수, CPI 하나만 가지고 성능을 예측하는 방법의 위험에 대하여 경고한 바 있음.<br>
세 가지 인자들 중에서 2개만을 사용하여 성능을 비교하는 것은 위험함.<br>
실행시간 대신에 쓸 수 있는 척도로 MIPS(Million Instructions Per Second)가 있음.<br>
MIPS = 명령어 개수 / (실행시간 * 10^6)<br>
MIPS는 명령어 실행 속도이므로 실행시간의 역수로 성능을 표시함.<br>
따라서 빠른 컴퓨터일수록 높은 MIPS 값을 가짐.<br>
컴퓨터의 성능을 비교하는 기준으로 MIPS를 사용하는 데는 세 가지 문제점이 있음.<br>
첫쨰로 MIPS는 단순히 명령어를 실행하는 속도를 나타낼 뿐이지, 그 명령어 하나가 얼마나 많은 일을 수행하는지는 반영하지 못 함.<br>
둘째로 같은 컴퓨터에서도 어떤 프로그램을 실행하느냐에 따라 MIPS 값은 달라짐. 그러므로 컴퓨터의 MIPS 값은 하나가 아님.<br>
MIPS = 명령어 개수 / ( ( 명령어 개수 * CPI / 클럭속도) * 10^6 ) = 클럭 속도 / (CPI * 10^6)<br>
CPI가 4배 차이나면 MIPS도 4배 차이가 나는 것임.<br>
많은 명령어를 실행하지만 빠른 명령어를 사용하는 프로그램으로 바꾸는 경우, 컴퓨터 성능과는 반대로 MIPS 값이 작아짐.<br>
 
<h2><a id="2">:pencil2: Chapter2. 명령어: 컴퓨터 언어</a></h2>

**:pushpin: 부호있는 수와 부호없는 수**
 
 어떤 기수의 숫자에서 i번째 숫자 d의 값은 d * Base^i와 같음.<br>
 여기서 i는 0에서 시작해서 왼쪽으로 갈수록 증가함.<br>
 이 방식으로 워드 내의 비트에 번호를 붙일 수 있음.<br>
 그 비트에 해당하는 기수의 거듭제곱수를 번호로 사용함.<br>
 1011two는 (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (1 * 2^0)tem = 11ten임.<br>
 가장 오른쪽, 왼쪽 비트라고 말하는 것이 모호할 수 있어서 LSB(Least Significant bit), MSB(Most Significant bit)라고 부름.<br>
 RISC-V 워드의 길이는 32비트이므로 2^32가지의 서로 다른 32비트 패턴을 표현할 수 있음.<br>
 이 조합이 0부터 2^32-1(4,294,967,295tem)까지의 숫자를 표시하게 해줌.<br>
 00000000 00000000 00000000 00000000two = 0ten<br>
 ...<br>
 11111111 11111111 11111111 11111111two = 4,294,967,295ten<br>
 32비트 이진수는 비트값과 2의 제곱수를 곱한 값으로 표현할 수 있음.<br>
 (x31 * 2^31) + (x30 * 2^30) + ... + (x1 * 2^1) + (x0 * 2^0)<br>
 
 **하드웨어/소프트웨어 인터페이스**<br>
 
 오버플로: 연산의 결과가 레지스터에서 표현될 수 있는 수보다 클 때.<br>
 양수와 음수를 구별하는 표현 방법이 필요해서 나온 것 중 하나가 부호와 크기(sign and magnitude) 표현법임.<br>
 부호와 크기 표현법은 몇 가지 단점이 있음.<br>
 첫 째, 어디에 부호 비트를 붙여야 하는지가 명확하지 않음.<br>
 둘 째, 부호와 크기 표현법의 덧셈기는 부호를 결정하기 위해 한 단계가 더 필요함. 왜냐하면 최종 부호가 무엇이 될지를 미리 알 수 없기 때문임.<br>
 마지막으로 부호 비트가 따로 붙기 때문에 양의 0과 음의 0을 가짐.<br>
 이런 단점들 때문에 부호와 크기 표현법은 잘 쓰지 않게 됨.<br>
 
 **2의 보수(two's complement) 표현법**
 <pre>
 0이 앞에 나오면 양수이고, 1이 앞에 나오면 음수임.<br>
 00000000 00000000 00000000 00000000two = 0ten<br>
 00000000 00000000 00000000 00000001two = 1ten<br>
 ...<br>
 01111111 11111111 11111111 11111111two = 2,147,483,647ten<br>
 10000000 00000000 00000000 00000000two = -2,147,483,648ten<br>
 10000000 00000000 00000000 00000000two = -2,147,483,647ten<br>
 ...<br>
 11111111 11111111 11111111 11111110two = -2ten<br>
 11111111 11111111 11111111 11111111two = -1ten<br>
 </pre>
 2의 보수 표현에서 모든 음수는 MSB가 1이라는 장점이 있음.<br>
 따라서 하드웨어가 양수인지 음수인지 알아보려면 MSB만 검사하면 됨.(0은 양수 취급)<br>
 그러므로 MSB를 부호 비트라고 부름.<br>
 부호 비트의 역할을 이해하면, 비트값에 2의 거듭제곱수를 곱한 값으로 32비트의 양수와 음수를 모두 표현할 수 있음.<br>
 (x31 * -2^31) + (x30 * 2^30) + ... + (x1 * 2^1) + (x0 * 2^0)<br>
 2의 보수 연산에서도 오버플로가 발생함.<br>
 무한히 많은 비트 수로 표현한다면 왼쪽에 무수히 나타날 비트와 실제 이진 비트 패턴의 왼쪽 비트가 서로 다를 때(즉, 부호 비트가 틀렸을 때) 오버플로가 발생한 것임.<br>
 <br>
 부호있는 수와 부호없는 수는 산술 연산뿐만 아니라 적재 명령어와도 상관이 있음.<br>
 부호있는 적재의 기능은 레지스터의 남는 곳을 채우기 위해 부호를 반복하여 복사하는 것임.(부호확장, sign extension)<br>
 그 목적은 레지스터 내에 숫자의 정확한 표현을 넣는 것임.<br>
 부호없는 적재의 경우에는 단순히 데이터의 왼쪽을 0으로 채우면 됨.<br>
 이 비트 패턴이 표현하는 수에는 부호가 없기 때문임.<br>
 32비트 레지스터에 32비트 워드를 적재할 경우에는 부호있는 적재와 부호없는 적재가 동일함.<br>
 lbu(load byte unsigned) 명령어는 바이트를 부호없는 수로 간주하고 남은 24비트를 0으로 채움.<br>
 lb(load byte) 명령어는 바이트를 부호있는 정수로 간주하여 부호확장한 후 레지스터를 채움.<br>
 C프로그램의 바이트는 대부분의 경우 매우 짧은 부호있는 정수보다는 문자를 표시하는데 사용되므로, 바이트 적재에 실제로는 lbu 명령어만 사용됨.<br>
 메모리 주소는 자연스럽게 0에서부터 시작해 가장 큰 주소까지 이어짐. 음수 주소는 의미가 없음.<br>
 따라서 프로그램이 양수도 될 수 있고, 음수도 될 수 있는 수를 다루기를 원할 때도 있고, 양수값만 찾는 수를 다루고자 할 때도 있음.<br>
 C언어에서 전자를 정수(int)라고 하고, 후자를 부호없는 정수(unsinged int)라고 함.<br>
 
 **2의 보수 연산**<br>
 빠른 부호 바꾸기 방법은 모든 0은 1로, 1은 0으로 바꾼 뒤 1을 더하는 것임.<br>
 이는 원래 수와 모든 비트를 역전시킨 수의 합이 -1이라는 것에 기초하고 있음.<br>
 x + xbar = -1이므로 x + xbar + 1= 0임.<br>
 빠른 부호확장 방법은 n비트로 표현된 이진수를 n비트보다 긴 수로 바꾸는 방법임.<br>
 짧은 이진수의 최상위 비트를 취해서 비어 있는 왼쪽 부분에 채우고, 원래의 n비트 값은 긴 수의 오른쪽 부분에 그대로 복사하는 것임.<br>

 컴퓨터 워드에 양수와 음수를 모두 나타낼 필요가 있음.<br>
 여러가지 방식이 제안되어 왔지만 1965년 이후에는 2의 보수 표현법으로 통일됨.<br>
 
 부호있는 십진수는 크기에 대한 제한 사항이 없기 때문에 음수를 표현하기 위해 -를 사용함.<br>
 하지만 이진수와 16진수 비트열은 고정된 워드 크기 내에서 부호를 표시할 수 있으므로 일반적으로 +나 -를 사용하지 않음.<br>
 
 **다양한 표현법**<br>
 
 2의 보수법이란 이름은 n비트의 수와 그 음수의 합을 부호없는 수로 나타내면 2^n이 된다는 법칙에서 비롯됨.<br>
 x + x보수 = 2^n이므로 x보수 = 2^n - x임.<br>
 1의 보수 표현법은 비트의 0과 1을 맞바꾸어서 음수를 만들 수 있으며, x의 보수는 2^n - x - 1임.<br>
 1의 보수 표현법은 0이 두 가지로 표현되는 것을 제외하면 2의 보수법과 비슷함.<br>
 00...00two는 양의 0이고, 11...11two는 음의 0임.<br>
 가장 작은 음수 10...00two는 -2,147,483,647ten을 나타내며, 따라서 양수와 음수의 개수는 같음.<br>
 마지막 표현법은 절대값이 가장 큰 음수를 00...00two로 표현하고, 가장 큰 양수는 11...11two로 표현하며, 0은 10...00two로 표현하는 방식임.<br>
 이 표현을 부동 소수점을 다룰 때 보게됨.<br> 
 숫자에 바이어스 값을 더하여 항상 양수로 표현하기 때문에 이 방식을 바이어스된 표현법(biased notation)이라고 함.<br>
 
**:pushpin: 문자와 문자열**
 
 오늘날 대부분의 컴퓨터는 8비트 바이트로 문자를 표현하며, 거의 모든 컴퓨터가 ASCII(American Standard Code for Information Interchange)를 사용함.<br>
 명령어 몇 개를 사용하면 워드 내의 특정 바이트를 추출할 수 있음.<br>
 그러므로 적재 명령어 lw와 저장 명령어 sw는 워드뿐 아니라 바이트 전송에도 사용될 수 있음.<br>
 하지만 효율성을 위해 RISC-V에는 바이트 전송 명령어가 따로 있음.<br>
 lbu(load byte unsigned)는 메모라에서 한 바이트를 읽어서 레지스터의 오른쪽 8비트에 채우는 명령임.<br>
 sb(store byte)는 레지스터의 오른쪽 8비트를 메모리로 보내는 명령어임.<br>
 한 바이트를 복사할 때는 다음과 같이 할 수 있음.<br>

 <pre>
 lbu x12, 0(x10) //Read byte from source
 sb x12, 0(x11) //Write byte to destination
 </pre>
 
 문자 데이터는 보통 여러 개가 모여서 문자열(string)을 이루는데, 문자열의 길이는 가변적임.<br>
 가변 길이의 문자열을 표현하는 방법에는 세 가지가 있음.<br>
 첫 째, 맨 앞에 길이를 표시하는 방법.<br>
 둘 째, 같이 사용되는 변수에 그 길이를 표시하는 방법.<br>
 마지막, 문자열의 끝을 표시하는 특수 문자를 두는 방법.<br>
 C 언어는 문자열의 끝에 0값(ASCII의 null)을 두는 세 번째 방법을 사용함.<br>
 그러므로 Cal은 67, 97, 108, 0의 네 바이트로 표현됨.<br>
 JAVA는 첫 번째 방법을 사용함.<br>
  
<pre>  
strcpy:                   // strcpy 함수 시작점을 나타냄
  addi sp, sp, -4         // 스택 포인터 조정: 스택 포인터를 4바이트 감소시켜 스택 공간을 할당함. 이는 함수 내에서 스택 메모리를 사용하기 위한 작업임.
  sw x19, 0(sp)          // 현재 레지스터 x19에 저장된 값을 스택 메모리 가장 상위에 있는 메모리 공간에 저장함. 이는 나중에 함수에서 x19 레지스터의 값을 복원하기 위한 작업임.
  add x19, x0, x0        // i = 0 + 0 (i를 0으로 초기화), x19 레지스터에 0을 저장함.
  
L1:                      // 반복문 시작
  add x5, x19, x11       // x11은 배열 y의 시작 주소를 가리키고, x19는 현재 i값을 가지고 있음. 따라서 y[i]의 주소를 계산하여 x5에 저장함.
  lbu x6, 0(x5)          // y[i] 값을 로드하여 x6에 저장
  add x7, x19, x10       // x10은 배열 x의 시작 주소를 가리키고, x19는 현재 i값을 가지고 있음. 따라서 x[i]의 주소를 계산하여 x7에 저장함.
  sb x6, 0(x7)           // x[i]에 y[i] 값을 저장함. sb는 바이트 단위로 값을 저장하는데, 이는 값이 부호 없는 문자임을 가정하기 때문임.
  beq x6, x0, L2         // y[i]가 NULL이면 (0이면) 복사 작업이 끝났으므로 L2로 점프
  addi x19, x19, 1       // i = i + 1
  jal x0, L1             // L1로 점프하여 반복함. 이는 다시 y[i+1] 값을 읽어 x[i+1]에 저장하기 위함임.
  
L2:                      // 반복문 종료
  lw x19, 0(sp)          // 스택에서 x19에 저장된 값을 로드하여 복원
  addi sp, sp, 4         // 스택 포인터 조정: 스택에서 4바이트 크기의 공간을 해제하여 사용
  jair x0, 0(x1)         // strcpy 함수에서 호출된 함수로 되돌아감. 이는 함수 호출 이전 상태로 프로그램 카운터를 복원하는 역할을 함.
</pre>

스택 포인터: 메모리에서 현재 사용 중인 스택의 맨 위에 위치하는 메모리 주소를 가리키는 레지스터임.<br>
레지스터: CPU 내부에 있는 소규모 메모리 공간으로, CPU가 자주 액세스하는 데이터를 저장함.<br>
add: 주어진 레지스터의 값을 더하여 결과를 저장함.<br>
 
 프로시저 strcpy는 말단 프로시저이므로 컴파일러가 i를 임시 레지스터에 할당했으면 x19를 저장하고 복구하는 일을 피할 수도 있었음.<br>
 그러므로 임지 레지스터들을 단순히 임시용으로 생각하지 말고, 피호출 프로그램이 편리할 때 사용하는 레지스터로 생각하는 것이 좋음.<br>
 실제로 컴파일러가 말단 프로시저를 만나면 우선 이런 임시 레지스터들을 쓰고 부족하면 그 때 저장해야 하는 레지스터를 사용함.<br>
 
 **JAVA의 문자와 문자열**<br>
 유니코드(Unicode)는 인간이 사용하는 거의 모든 언어의 자모(alphabet)를 수용할 수 있는 범용 인코딩임.<br>
 유니코드에는 ASCII의 기호만큼이나 많은 자모가 있음.<br>
 Java는 포괄성을 위해 문자를 유니코드로 표현함.<br>
 그러므로 문자 표현에 16비트를 사용하는 것이 디폴트임.<br>
 RISC-V 명령어 집합에는 하프워드라 불리는 16비트 데이터에 대한 적재와 저장 명령어가 포함되어 있음.<br>
 lhu(load half unsigned) 명령은 메모리에서 비트를 읽어 와서 레지스터의 우측 16자리에 넣음.<br>
 왼쪽 16비트는 0으로 채움.<br>
 lb처럼 lh(load half)도 하프워드를 부호있는 수로 취급하므로, 레지스터의 왼쪽 비트를 부호 확장하여 채움.<br>
 sh(store half)는 레지스터의 우측 16비트를 메모리에 씀.<br>
 다음과 같이 하면 하프워드를 복사할 수 있음.<br>
 
 <pre>
 lhu x19, 0(x10) // Read halfword(16 bits) from source
 sh x19, 0(x11) // Write halfword (16 bits) to destination
 </pre>

 문자열은 내장된 특별 지원 기능과 사전 정의된 연접, 비교, 변환 메소드를 가지고 있는 표준 Java 클래스임.<br>
 C와 달리 java 문자열은 길이를 나타내는 워드를 포함하고 있음.<br>
 RISC-V 소프트웨어는 스택을 "쿼드워드(16바이트)" 주소에 맞춰 정렬함.<br>
 16바이트면 충분한 char 변수도 스택에 저장할 때는 16바이트를 할당함.<br>
 그러나 C 문자열 변수나 바이트 배열은 한 쿼드워드에 16바이트씩 묶어서 넣음.<br>
 JAVA의 문자열 변수나 short 배열은 한 쿼드워드에 8개의 하프워드씩 넣음.<br>
 웹은 국제적이라는 특성이 있기 때문에 이를 반영하여 대부분의 웹 페이지들은 ASCII 대신에 Unicode를 사용함.<br>
 따라서 오늘날에는 ASCII보다 Unicode가 더 인기있음.<br>

**추가**<br>

Intel IA32는 인텔이 1985년에 처음으로 출시한 32비트(x86) 아키텍처임.<br>
이 아키텍처는 32비트 모드에서만 동작하며, 최대 4GB의 메모리를 지원함.<br>
이제는 더 이상 사용되지 않음.<br>
X86-64(인텔 64 또는 AMD64)는 64비트(x86) 아키텍처임.<br>
인텔과 AMD가 공동으로 개발하였으며, IA32와의 하위 호환성을 제공함.<br>
그러므로 기존에 IA32용으로 작성된 소프트웨어도 X86-64에서 동작할 수 있음.<br>
이 아키텍처는 IA32와 비교하여 더 많은 메모리를 지원하며, 더 많은 레지스터와 SIMD(Single Instruction Multiple Data) 명령어 등을 지원함.<br>
현재 대부분의 컴퓨터에서는 X86-64 아키텍처를 사용하고 있음.<br>
