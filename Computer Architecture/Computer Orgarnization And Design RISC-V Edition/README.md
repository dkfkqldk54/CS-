<h1>:green_book: <Computer Orgarnization And Design RISC-V Edition> 정리</h1>

<a href="#1">:pencil2: Chapter1. 컴퓨터 추상화 및 관련 기술</a>
- 컴퓨터 구조 분야의 일곱 가지 위대한 아이디어
- 프로그램 밑의 세계
- 케이스를 열고
- 프로세서와 메모리 생산 기술
- 성능
- 전력 장벽
- 현저한 변화: 단일프로세서에서 멀티프로세서로의 변화
- 오류 및 함정

 <a href="#2">:pencil2: Chapter2. 명령어: 컴퓨터 언어</a>
 - 하드웨어 
 - 피연산자
 - 부호있는 수와 부호없는 수
 - 명령어의 컴퓨터 내부 표현
 - 문자와 문자열
 
  <a href="#3">:pencil2: Chapter3. 컴퓨터 연산</a>
 - 덧셈과 뺄셈
 - 곱셈
 - 나눗셈
 - 부동 소수점

<h2><a id="1">:pencil2: Chapter1. 컴퓨터 추상화 및 관련 기술</a></h2>

**:pushpin: 컴퓨터 구조 분야의 일곱 가지 위대한 아이디어**

- 설계를 단순화 하는 추상화: 하위 수준의 상세한 사항을 안 보이게 함으로써 상위 수준 모델을 단순화함.<br>
- 자주 생기는 일을 빠르게: 드물게 생기는 일을 최적화하는 것보다 성능 개선에 도움이 됨.<br>
- 병렬성을 통한 성능 개선<br>
- 파이프라이닝을 통한 성능 개선<br>
- 예측을 통한 성능 개선<br>
- 메모리 계층 구조: 최상위 계층에는 가장 빠르고, 가장 작고, 비트당 가격이 제일 비싼 메모리를 사용하고, 최하위 계층에는 느리지만 크고 비트당 가격이 제일 싼 메모리를 사용함.<br>
- 여유분을 이용한 신용도 개선: 모든 물리 소자는 장애가 발생할 수 있으므로, 장애를 감지하고 장애가 난 소자를 대치할 수 있도록 여유분을 준비하면 컴퓨터의 신용도를 개선할 수 있음.<br>

**:pushpin: 프로그램 밑의 세계**

소프트웨어들은 계층적으로 구성됨. 응용 프로그램이 가장 바깥쪽에 위치하며, 여러 가지 시스템 소프트웨어가 하드웨어와 응용 소프트웨어 사이에 존재함.<br>
시스템 소프트웨어는 여러가지가 있으나 대표적으로 운영체제와 컴파일러가 있음.<br>
운영체제는 사용자 프로그램과 하드웨어 간의 인터페이스 역할을 하면서 각종 서비스와 감독 기능을 제공함.<br>
기본적 입출력 작업의 처리, 보조기억장치 및 메모리 할당, 컴퓨터를 동시에 사용하는 여러 응용들 간의 컴퓨터 공유 방법 제공 등 기능이 있음.<br>
오늘날 사용되고 있는 운영체제의 예로는 Windows, Linux, iOS, Android 등이 있음.<br>
컴파일러는 C, C++, Java, Visual Basic 같은 상위 수준 언어로 작성된 프로그램을 하드웨어가 실행할 수 있는 명령어로 번역하는 일을 함.<br>

**상위 수준 언어에서 기계어까지**

기계어는 기수 2인 숫자, 즉 이진수라고 생각함.<br>
각 문자를 이진 자릿수 또는 비트라고 부름.<br>
명령어(instruction)는 컴퓨터 하드웨어가 이해하고 실행하는 명령임.<br>
어셈블러는 기호로 된 명령어(어셈블리 언어)를 이진수 프로그램으로 번역하는 프로그램임.<br>
예를 들어 add A, B라고 쓰면 어셈블러가 이것을 1001010100101110으로 바꿈.<br>
기계가 이해하는 언어는 기계어라고 부름.<br>
어셈블리 언어는 컴퓨터가 실행할 명령어를 한 줄에 하나씩 써야하기 때문에 프로그래머에게 기계식 사고 방식을 강요함.<br>
상위 수준 언어에서 A + B가 있으면 컴파일러는 이것을 번역해서 add A, B와 같은 어셈블리 언어 문장으로 바꿈.<br>

**:pushpin: 케이스를 열고**
 
 모든 컴퓨터의 하드웨어는 데이터 입력, 출력, 처리, 저장 네 가지 기본 기능을 수행함.<br>
 입력장치는 키보드나 마우스와 같이 컴퓨터에 정보를 공급하는 장치임.<br>
 출력장치는 연산의 결과를 사용자나 다른 컴퓨터에 보내주는 장치임.<br>
 컴퓨터의 고전적 구성 요소 다섯 가지는 입력, 출력, 메모리, 데이터패스, 제어 유닛임. 데이터패스와 제어 유닛을 합쳐서 프로세서라고 부르기도 함.<br>
 프로세서는 메모리에서 명령어와 데이터를 읽음.<br>
 입력장치는 메모리에 데이터를 쓰고, 출력장치는 메모리에서 데이터를 읽음.<br>
 제어 유닛은 데이터패스, 메모리, 입력장치, 출력장치의 동작을 결정하는 신호를 내보냄.<br>
 
 **디스플레이**<br>
 
 개인 휴대용 기기들은 얇고 전력 소모가 적은 LCD(Liquid crystal display)를 사용함.<br>
 LCD는 스스로 빛을 내는 대신 통과하는 빛을 제어함.<br>
 전형적인 LCD에는 액체 상태의 막대 모양 분자가 있어서 디스플레이에 들어오는 빛을 굴절시킴.<br>
 빛은 보통 디스플레이 뒤쪽의 광원에서 보내지며, 이보다 흔하지는 않지만 반사광을 이용하는 경우도 있음.<br>
 이 막대들이 보통 때는 꼬인 나선 모양으로 배열되어서 빛을 굴절시키다가 전류를 흘리면 똑바로 퍼져서 빛을 통과시킴.<br>
 90도로 편광된 두 스크린 사이에 액정 물질을 넣기 때문에 빛이 꺽이지 않는 한 통과할 수 없음.<br>
 오늘날 대부분의 LCD는 매 화소 위치마다 작은 트랜지스터를 배치하여 전류를 정밀하게 제어하는 능동 행렬을 사용하므로 더욱 선명한 이미지를 제공함.<br>
 매 화소마다 R-G-B 마스크가 있어서 각 원색의 강도를 결정함. 따라서 컬러 능등 행령 LCD에는 화소마다 3개의 트랜지스터 스위치가 있음.<br>
 화소는 영상을 구성하는 제일 작은 원소를 뜻함.<br>
 각 화상은 화소의 행렬로 구성되며, 이것은 비트맵이라 부르는 비트들의 행렬로 표현됨.<br>
 디스플레이 행렬은 스크린의 크기와 해상도에 따라 1024 * 768에서 2048 * 1536개의 화소로 구성됨.<br>
 컬러 디스플레이는 빛의 삼원색(빨강, 파랑, 초록) 각각마다 8비트씩, 모두 24비트를 사용하여 수백만 가지의 색을 표시할 수 있음.<br>
 그래픽을 지원하는 하드웨어의 중심이 되는 것은 비트맵을 기억하는 프레임 버퍼라고 하는 부분임.<br>
 그래픽 하드웨어는 스크린에 표시될 화상을 프레임 버퍼에 저장하였다가, 기억된 각 화소의 비트 패턴을 재생 속도에 맞추어 그래픽 디스플레이로 보냄.<br>
 
 **터치스크린**<br>
 
 태블릿과 스마트폰은 키보드와 마우스 대신 터치를 감지하는 디스플레이를 사용하고 있음.<br>
 터치스크린을 구현하는 방법 중 하나는 정전용량 감지 기법임.<br>
 유리 같은 절연체 위에 투명한 도체를 코팅하면, 사람이 손을 댔을 때 손에 전기가 통하기 때문에 스크린의 정전기장이 찌그러지면서 정전용량이 변하게 됨.<br>
 
 **상자를 열고**<br>
 
 집적회로는 칩이라고도 부름. 수천만 개의 트랜지스터가 결합된 부품임.<br>
 CPU는 프로세서라고도 부름. 데이터패스와 제어 유닛으로 구성된 컴퓨터의 핵심 부분임. 숫자를 더하거나 검사하고, 입출력장치에 신호를 보내 활성화하는 일을 함.<br>
 데이터패스는 산술 연산을 수행하는 프로세서의 구성 요소임.<br>
 제어 유닛은 프로그램의 명령어에 따라 데이터패스, 메모리, 입출력장치에 지시를 하는 프로세서 구성 요소임.<br>
 메모리는 실행 중인 프로그램과 프로그램 실행에 필요한 데이터의 저장소임. 메모리는 DRAM 칩으로 구성되어 있음.<br>
 DRAM(Dynamic Random Access Memory)은 집적회로로 만든 메모리의 일종임. 어떤 위치든지 임의로 접근할 수 있음. 접근 시간은 50ns정도임.<br>
 DRAM 여러 개를 한데 묶어서 프로그램의 명령어와 데이터를 기억하는데 사용함.<br>
 DRAM에서 RAM은 자기 테이프 같은 순차 접근 메모리와는 반대로 메모리의 어떤 부분을 읽든지 같은 시간이 걸린다는 것을 의미함.<br>
 프로세서 내부에는 또 다른 종류의 메모리가 있는데 이것을 캐시 메모리라고함.<br>
 캐시 메모리는 DRAM의 버퍼 역할을 하는 작고 빠른 메모리임.<br>
 캐시는 SRAM(Static Random Access Memory)이라는 메모리 기술을 이용함. SRAM은 DRAM보다 빠르지만 집적도가 낮아서 가격이 비쌈.<br>
 SRAM과 DRAM은 메모리 계층구조의 두 계층을 구성함.<br>
 소프트웨어는 하드웨어와 어휘를 통해 통신함.<br>
 어휘를 구성하는 단어들을 명령어라고 하고, 어휘 자체는 명령어 지밥 구조(Instruction Set Architecture) 또는 단순히 구조라고 함.
 응용 프로그래머에게 제공되는 기본 명령어 집합과 운영체제 인터페이스를 합쳐서 ABI(Application Binary Interface)라고 함.<br>
 
 **데이터의 안전한 저장소**<br>
 
메인 메모리: 휘발성 메모리라고도 함. DRAM과 같이 전원이 공급되는 동안만 데이터를 기억하는 기억장치임.<br>
보조기억장치: 비휘발성 메모리라고도 함. 전원 공급이 끊어져도 데이터를 계속 기억하는 기억장치로, 다음 실행 때까지 프로그램을 저장하는 데 사용됨. 보조기억장치는 메모리 계층구조에서 메인 메모리보다 한 단계 아래 계층에 해당함.<br>
 DRAM이 메인 메모리의 주종을 이루고 있으며, 자기 디스크는 그 전부터 보조기억장치의 주종이 되었음.<br>
 개인 휴대용 기기는 크기와 모양의 제약 때문에 자기 디스크 대신 비휘발성 반도체 메모리인 플래시 메모리를 사용함.<br>
 플래시 메모리는 DRAM보다 느리지만, DRAM보다 훨씬 싸고 비휘발성이라는 장점이 있음.<br>
 디스크보다 비트당 단가는 비싸지만, 작고 튼튼하며 전력 소모가 적고 훨씬 소용량으로 생산될 수 있음.<br>
 그래서 PMD(Persistent Memory Device, 영구 저장이 가능한 비휘발성 메모리를 의미)의 표준 보조기억장치로 사용됨. 하지만 DRAM이나 자기 디스크와 달리 플래시 메모리는 10만번 내지 100만번 쓰기를 한 후에는 못 쓰게 됨.<br>
 
 **컴퓨터 간의 통신**<br>
 
 네트워크로 컴퓨터를 연결했을 때의 장점은 통신, 자원 공유, 원격 접근 등이 있음.<br>
 네트워크 중에서 가장 널리 알려진 것은 이더넷(Ethernet)임.<br>
 이더넷으로 연결할 수 있는 거리는 대략 1km 정도이고, 초당 100Gb를 전송할 수 있음.<br>
 한 건물의 같은 층에 있는 컴퓨터들을 연결하는데 유용한 근거리 네트워크(Local Area Network, LAN)의 일종임.<br>
 라우터 서비스와 보안을 제공하는 스위치를 사용하면 LAN들을 서로 연결할 수 있음.<br>
 원거리 네트워크(Wide Area Network, WAN)는 여러 대륙을 연결하여 웹(world Wide Web)을 지원하고 있는 인터넷의 근간을 이룸.<br>

**:pushpin: 프로세서와 메모리 생산 기술**
 
 집적회로 칩의 생산은 모래의 구성 성분인 실리콘에서부터 출발함.<br>
 실리콘은 전기가 통하기는 하는데 완전 잘 통하는 것은 아니어서 반도체임.<br>
 특수한 화학적 처리를 거쳐 불순물을 첨가하면 실리콘의 작은 부분을 세 가지 중 하나로 바꿀 수 있음.<br>
 전기 양도체(초소형 구리나 알루미늄 전선), 전기 절연체(플라스틱 피복이나 유리 등), 조건에 따라 도체가 되기도 하고 절연체가 되기도 하는 물질(스위치)<br>
 공정은 실리콘 결정 괴(silicon crystal ingot)에서부터 시작됨.<br>
 실리콘 괴의 직경은 8~12인치, 길이는 12~24인치 정도임.<br>
 이 덩어리를 0.1인치 이하의 두께로 얇게 잘라 웨이퍼를 만듦.<br>
 웨이퍼는 화학 물질을 첨가하여 부분 부분을 트랜지스터, 도체, 절연체로 바꾸는 일련의 공정을 거치게 됨.<br>
 빈 웨이퍼에는 패턴이 새겨지는데, 이를 웨이퍼 검사기로 검사해서 불량 부분에 표시함.<br>
 웨이퍼 자체에 미세한 흠집이 있었거나 여러 공정 중에 어느 한 부분에서라도 흠집이 생기면 웨이퍼의 그 부분은 못 쓰게 되는데, 이러한 결함 때문에 완벽한 웨이퍼를 만드는 건 거의 불가능함.<br>
 불완전성에 대처하기 위해 한 웨이퍼에 독립적인 컴포넌트를 여러 개 만들고, 웨이퍼를 컴포넌트별로 자르는데 이것을 다이 또는 칩이라고 함.<br>
 여러 조각으로 나누면 웨이퍼에 결함이 생겼을 때 웨이퍼 전체를 버리는 대신 해당 다이만 버리면 됨. 이 개념을 수율로 계량화 할 수 있음.<br>
 한 웨이퍼에서 20개의 다이가 만들어지고 그 중 17개만이 검사를 통과하면 수율은 85%임.<br>
 다이 크기가 커지면 웨이퍼에 넣을 수 있는 다이가 적어지고 수율이 떨어지므로 집적회로 가격이 급속히 증가함.<br>
 차세대 프로세스를 이용해서 트랜지스터와 연결선의 크기를 줄임으로써 큰 다이를 축소시켜 원가 절감을 꾀하기도 함.<br>
 이렇게 하면 수율과 웨이퍼당 다이 개수가 개선됨.<br>
 다이가 10 nm 공정을 사용하고 있다는 말은 가장 작은 트랜지스터의 크기가 10nm라는 뜻임.<br>
 하지만 트랜지스터는 실제 최소 배선폭보다 더 작은 것이 보통임.<br>
 최소 배선폭이란 최종 생산된 트랜지스터의 크기가 아니라 마스크에 그려진 크기를 뜻하는 것임.<br>
 결함이 없는 다이는 패키지의 입출력 핀과 연결하는데 이 과정을 본딩이라고 함.<br>
 납품하기 전에는 다시 한번 검사를 거침.<br>
 
 **집적회로 가격**<br>
 
 다이 원가 = 웨이퍼당 가격 / (웨이퍼당 다이의 수 * 수율)<br>
 웨이퍼당 다이의 수 = 웨이퍼의 면적 / 다이의 면적<br>
 수율 = 1 / (( 1 + (면적당 결함의 수 * 다이 면적 ) ) ^ n)<br>
 n은 공정의 수인데, 공정이 많을 수록 수율은 떨어짐.<br>
 
**:pushpin: 성능**
 
 성능x = 1 / 실행시간x<br>
 성능x > 성능y는 1 / 실행시간x > 1 / 실행시간y랑 같으므로 실행시간y > 실행시간x와 같은 말임.<br>
 X가 Y보다 n배 빠르다면 성능x / 성능y = 실행시간y / 실행시간x = n임.<br>
 
 **성능의 측정**<br>
 
 보통 성능을 측정하기 위해 사용하는 시간은 벽시계 시간, 응답시간, 경과시간 등이 있음.<br>
 이것은 한 작업을 끝내는 데 필요한 전체 시간을 뜻하는 것으로 디스크 접근, 메모리 접근, 입출력 작업, 운영체제 오버헤드 등 모든 시간을 다 더한 것임.<br>
 컴퓨터를 공유하는 경우, 프로세서 하나가 여러 프로그램을 동시에 실행하는 경우가 많이 있음.<br>
 그러므로 경과시간과 구분해서 프로세서가 순수하게 이 프로그램을 실행하기 위해 소비한 시간을 계산할 필요가 있음.<br>
 이 시간을 CPU 실행시간 또는 CPU 시간이라고 함.<br>
 CPU 시간은 실제로 사용자 프로그램 실행에 소요된 사용자 CPU 시간과 운영체제가 이 프로그램을 위한 작업을 수행하기 위해 소비한 시스템 CPU 시간으로 다시 나눌 수 있음.<br>
 그러나 운영체제의 각 작업이 어떤 프로그램을 위해서 수행되고 있는가를 명확히 가려내는 것이 어렵고 운영체제 간의 기능 차이도 있기 때문에 시스템 CPU 시간과 사용자 CPU 시간을 정확히 구하는 것은 어려움.<br>
 다른 부하가 없는 시스템에서의 경과시간으로 계산한 것을 시스템 성능, 사용자 CPU 시간으로 계산한 것을 CPU 성능이라고 부름.<br>
 거의 모든 컴퓨터는 하드웨어 이벤트가 발생하는 시점을 결정하는 클럭을 이용하여 만들어짐.<br>
 이 클럭의 시간 간격을 클럭 사이클이라 함.<br>
 클럭 주기는 한 클럭 사이클에 걸리는 시간(250ps 등)이나 클럭 속도(4 GHz 등)로 표시함.<br>
 클럭 속도는 클럭 주기의 역수임.<br>
 
 **CPU 성능과 성능 인자**<br>
 
 프로그램의 CPU 실행 시간 = 프로그램의 CPU 클럭 사이클 수 * 클럭 사이클 시간<br>
 프로그램의 CPU 실행 시간 = 프로그램의 CPU 클럭 사이클 수 / 클럭 속도<br>
 
 **명령어 성능**<br>
 
 CPU 클럭 사이클 수 = 명령어 수 * 명령어당 평균 클럭 사이클 수<br>
 명령어당 클럭 사이클 수(clock cycles per instruction)은 CPI로 줄여 쓰기도 함.<br>
 명령어마다 실행시간이 다르므로 CPI는 프로그램이 실행한 모든 명령어에 대해 평균한 값을 사용함.<br>
 명령어 집합 구조가 같으면 프로그램에 필요한 명령어 수가 같으므로, CPI는 서로 다른 구현을 비교하는 한 가지 기준이 될 수 있음.<br>
 
 **고전적인 CPU 성능식**<br>
 
 CPU 시간 = 명령어 개수 * CPI * 클럭 사이클 시간<br>
 CPU 시간 = 명령어 개수 * CPI / 클럭 속도<br>
CPU 실행시간은 실제 프로그램을 실행시켜서 얻을 수 있고, 클럭 사이클 시간은 보통 컴퓨터의 하드웨어 매뉴얼에 기록되어 있음.<br>
 그러나 명령어 개수와 CPI는 구하기가 어려움.<br>
 물론 클럭 속도와 CPU 실행시간을 알 때, 명령어 개수나 CPI 중 하나를 알면 다른 하나는 계산으로 구할 수 있음.<br>
 명령어 개수는 실행 과정을 추적하는 소프트웨어 도구나 컴퓨터 구조의 시뮬레이터를 이용해서 측정할 수 있음.<br>
 그 외에 하드에어 카운터를 사용하면 실행 명령어 수나 평균 CPI, 심지어는 성능 저하의 원인까지 찾아낼 수 있음.<br>
 명령어 개수는 구조에 따라서 결정될 뿐 구현 방법과는 상관이 없으므로 자세한 구현 내용은 몰라도 구할 수 있음.<br>
 그러나 CPI는 프로그램 실행에 사용되는 명령어 배합뿐 아니라 메모리 시스템과 프로세서 구조를 포함하는 여러 가지 컴퓨터 세부 설계에 따라 달라짐.<br>
 따라서 CPI는 명령어 집합이 같더라도 구현 방식에 따라서 달라질 뿐 아니라 응용 프로그램에 따라서도 달라짐.<br>
 CPU 성능식의 인자에 영향을 미치는 요소는 알고리즘, 프로그래밍 언어, 컴파일러, 명령어 집합 구조 등이 있음.<br>
 CPI의 역수인 IPC(Instructions per clock cycle, 클럭 사이클당 명령어 수)도 사용함.<br>
 전통적으로 클럭 사이클 시간은 고정값을 사용해 왔지만, 오늘날의 프로세서는 에너지를 절약하거나 일시적으로 성능을 높이기 위해서 클럭 속도를 변경시키기도 함.<br>
 따라서 프로그램에 대한 평균 클럭 속도를 사용할 필요가 있음.<br>
 
**:pushpin: 전력 장벽**
 
 지난 36년간 클럭 속도와 소비 전력은 오랫동안 빠르게 증가하다가 최근에 주춤해지거나 감소함.<br>
 속도와 전력이 같이 증가하는 이유는 둘이 서로 연관되어 있기 때문임.<br>
 최근에 성장이 정체된 이유는 상용 마이크로프로세서의 냉각 문제 때문에 실제로 사용할 수 있는 전력이 한계에 도달했기 때문임.<br>
 집적 회로의 주된 기술인 CMOS(Complementary Metal Oxide Semiconductor)가 에너지를 소비하는 주 원인은 동적 에너지임.<br>
 동적 에너지란 트랜지스터가 0에서 1로 혹은 그 반대로 스위칭하는 동안에 소비되는 에너지를 말함.<br>
 동적 에너지는 옹량성 부하 * 전압^2로 결정됨.<br>
 이 식은 0 -> 1 -> 0 또는 1 -> 0 -> 1로 논리값이 두 번 바뀔 때 소모하는 에너지임.
 한 번 바뀔 때 소모되는 에너지는 (1/2) * 용량성 부하 * 전압^2임.<br>
 트랜지스터 하나가 소비하는 전력은 (1/2) * 용량성 부하 * 전압^2 * 스위칭빈도임.<br>
 스위칭 빈도는 클럭 속도의 함수임.<br>
 트랜지스터의 용량성 부하는 출력 단자에 연결된 트랜지스터의 개수(팬아웃)와 공정 기술의 함수임.<br>
 공정 기술은 도선과 트랜지스터의 용량을 결정함.<br>
 전력이 고작 30배 증가하는 동안 클럭 속도는 1000배 빨라질 수 있었던 이유는 새로운 공정이 나올 때마다 전압이 낮아졌고, 전력은 전압의 제곱에 비례하기 떄문임.<br>
 공정 기술 세대가 바뀔 때마다 대략 15%씩 전압이 줄어들었고, 20년 동안 전압은 5V에서 1V로 줄어들었는데, 이것이 전력이 고작 30배밖에 증가하지 않은 이유임.<br>
 오늘날의 문제는 전압을 더 이상 낮추면 트랜지스터 누설 전류가 너무 커진다는 것인데, 이는 꽉 잠기지 않는 수도꼭지의 문제와 같음.<br>
 서버 칩에서 현재 이미 40%의 전력이 누설 전류에 의해 소모되고 있음.<br>
 전력 문제 해결을 위해 설계자들은 이미 냉각이 잘 되도록 큰 장치를 부착해놓았으며, 클럭 사이클 단위로 사용하지 않는 부분을 꺼 버리는 방법을 쓰고 있음.<br>
 
**:pushpin: 현저한 변화: 단일프로세서에서 멀티프로세서로의 변화**

데스크탑 마이크로프로세서의 프로그램 응답시간 개선 속도는 2002년부터는 매년 1.5배에서 1.03배로 둔화됨.<br>
2006년에 모든 데스크탑과 서버 회사는 단일프로세서에서 한 프로그램의 응답 시간을 줄여 나가는 대신 마이크로프로세서 칩 하나에 여러 개의 프로세서를 집적하는 방식으로 전환함.<br>
이 방법은 응답시간보다 처리량 개선에 더 효과가 있음.<br>
프로세서와 마이크로프로세서 두 용어 사이의 혼란을 줄이기 위해 프로세서를 코어라고 부르고, 마이크로프로세서를 멀티코어 마이크로프로세서라고 부름.<br>

**병렬성**<br>
파이프라이닝은 명령어의 실행을 중첩시켜서 프로그램을 실행시키는 기술로 명령어 수준 병렬성의 한 예시임.<br>
파이프라이닝에서는 하드웨어의 병렬적인 특성이 드러나지 않아서 프로그래머와 컴파일러는 하드웨어가 명령어를 순차적으로 실행시키는 것으로 여길 수 있음.<br>
명시적 병렬 프로그램을 작성하는 것이 어려운 첫 번째 이유는 병렬 프로그래밍은 정의상 성능을 중시하는 프로그래밍이고, 이것이 프로그래밍의 어려움을 가중시키기 때문임.<br>
둘째 이유는 병렬 하드웨어에서 빠르게 실행된다는 것은 각 프로세서가 대략 비슷한 양의 일을 동시에 실행하도록 응용을 분할해야 하고, 병렬성으로부터 얻을 수 있는 잠재적인 성능의 이득을 침해하지 않도록 분할된 일을 스케줄링하고 조정하는 오버헤드가 작아야 함을 의미하기 떄문임.<br>
다른 모든 부분들이 끝나기 전에는 쓸 수 없는 부분이 있다면 이 또한 성능 미진의 이유가 될 수 있음. 통신 및 동기화 오버헤드를 줄이기 위해 각별한 주의가 요구됨.<br>

**:pushpin: 오류 및 함정**

**함정: 컴퓨터의 한 부분만 개선하고 그 개선된 양에 비례해서 전체 성능이 좋아지리라고 기대하는 것.**<br>

자주 생기는 일을 빠르게라는 아이디어는 성능을 개선하려는 노력이 얼마나 효과가 있는지는 그 사건이 얼마나 많이 발생하는지와 관련이 있다는 것임.<br>
개선 후의 프로그램 실행시간은 Amdahl의 법칙으로 표현할 수 있음.<br>
개선 후 실행시간 = 개선에 의해 영향을 받는 실행시간 / 개선의 크기 + 영향을 받지 않는 실행시간<br>

**오류: 이용률이 낮은 컴퓨터는 전력 소모가 작다.**<br>

서버는 작업부하가 가변적이기 때문에 이용률이 낮을 때의 전력 효율이 중요함.<br>
서버는 부하가 작을 때에도 최대 전력의 상당 부분을 사용하기 있기 때문임.<br>

**오류: 성능에 초점을 둔 설계와 에너지 효율에 초점을 둔 설계는 서로 무관하다.**<br>

에너지는 전력을 시간에 대해 적분한 것이므로, 어떤 하드웨어나 소프트웨어 최적화 기술이 에너지를 더 소비하더라도 실행시간을 줄여서 전체 에너지를 절약하기도 함.<br>
그 이유 중 하나는 프로그램이 실행되는 동안 최적화와 관련 없는 다른 부분이 에너지를 소모하기 때문에 실행시간이 짧아지면 시스템의 전체 에너지가 절약됨.<br>

**함정: 성능식의 일부분을 성능의 척도로 사용하는 것.**<br>

클럭 속도나 명령어 개수, CPI 하나만 가지고 성능을 예측하는 방법의 위험에 대하여 경고한 바 있음.<br>
세 가지 인자들 중에서 2개만을 사용하여 성능을 비교하는 것은 위험함.<br>
실행시간 대신에 쓸 수 있는 척도로 MIPS(Million Instructions Per Second)가 있음.<br>
MIPS = 명령어 개수 / (실행시간 * 10^6)<br>
MIPS는 명령어 실행 속도이므로 실행시간의 역수로 성능을 표시함.<br>
따라서 빠른 컴퓨터일수록 높은 MIPS 값을 가짐.<br>
컴퓨터의 성능을 비교하는 기준으로 MIPS를 사용하는 데는 세 가지 문제점이 있음.<br>
첫쨰로 MIPS는 단순히 명령어를 실행하는 속도를 나타낼 뿐이지, 그 명령어 하나가 얼마나 많은 일을 수행하는지는 반영하지 못 함.<br>
둘째로 같은 컴퓨터에서도 어떤 프로그램을 실행하느냐에 따라 MIPS 값은 달라짐. 그러므로 컴퓨터의 MIPS 값은 하나가 아님.<br>
MIPS = 명령어 개수 / ( ( 명령어 개수 * CPI / 클럭속도) * 10^6 ) = 클럭 속도 / (CPI * 10^6)<br>
CPI가 4배 차이나면 MIPS도 4배 차이가 나는 것임.<br>
많은 명령어를 실행하지만 빠른 명령어를 사용하는 프로그램으로 바꾸는 경우, 컴퓨터 성능과는 반대로 MIPS 값이 작아짐.<br>
 
<h2><a id="2">:pencil2: Chapter2. 명령어: 컴퓨터 언어</a></h2>

 **:pushpin: 하드웨어 연산**
 
 RISC-V 산술 명령어는 반드시 한 종류의 연산만 지시하며 항상 변수 3개를 갖음.<br>
 //의 오른쪽은 주석(comment)으로서 컴퓨터는 이것을 무시함.<br>
 고급 프로그래밍 언어와는 달리 한 줄에 명령어 하나만을 쓸 수 있으며, 줄이 끝나면 주석도 끝난다는 점이 C와는 다른 점임.<br>
 모든 명령어가 피연산자를 반드시 3개씩 갖도록 제한하는 것은 하드웨어를 단순하게 하자는 원칙과 부합함.<br>
 피연산자의 개수가 가변적이면 하드웨어가 복잡해짐.<br>
 설계 원칙 1: 간단하기 위해서는 규칙적인 것이 좋다.<br>
 
 <pre>
 32개의 레지스터(x0-x31)가 있으며 arithmetic을 숳애하기 위해서는 데이터가 레지스터에 들어와야 함.
 레지스터 x0은 항상 0임.
 2^30개의 memory words가 있음.
 Memory[0], Memory[4], ... , Memory[4,294,967,292]
 오직 data transfer instructions에 의해서만 접근이 가능함.
 RISC-V는 byte address를 사용하므로 sequential word는 4씩 차이가 남.
 Memory는 data structures, arrays, spilled registers를 hold함.
 </pre>
 
 <pre>
 Arithmetic
 
 add / add x5, x6, x7 / x5 = x6 + x7
 subtract / sub x5, x6, x7 / x5 = x6 - x7
 add immediate / addi x5, x6, 20 / x5 = x6 + 20
 
 Data transfer
 
 load word / lw x5, 40(x6) / x5 = Memory[x6 + 40]
 load word, unsigned / lwd x5, 40(x6) / x5 = Memory[x6 + 40]
 store word / sw x5, 40(x6) / Memory[x6 + 40] = x5
 load halfword / lh x5, 40(x6) / x5 = Memory[x6 + 40]
 load halfword, unsigned / lhu x5, 40(x6) / x5 = Memory[x6 + 40]
 store halfword / sh x5, 40(x6) / Memory[x6 + 40] = x5
 load byte / lb x5, 40(x6) / x5 = Memory[x6 + 40]
 load byte, unsigned / lbu x5, 40(x6) / x5 = Memory[x6 + 40]
 store byte / sb x5, 40(x6) / Memory[x6 + 40] = x5
 load reserved / lr.d x5, (x6) / x5 = Memory[x6] 여기서 d는 double word임.
 store conditional / sc.d x7, x5, (x6) / Memory[x6] = x5, 업데이트에 성공하면 x7 = 1, 실패하면 x7 = 0
 load upper immediate / lui x5, 0x12345 / x5 = 0x12345000 / 20 bit constant를 12bit left shifted 된 상태로 load함.
 
 Logical
 
 and / and x5, x6, x7 / x5 = x6 & x7
 inclusive or / or x5, x6, x8 / x5 = x6 | x8
 exclusive or / xor x5, x6, x9 / x5 = x6 ^ x9
 and immediate / andi x5, x6, 20 / x5 = x6 & 20
 inclusive or immediate / ori x5, x6, 20 / x5 = x6 | 20
 exclusive or immediate / xori x5, x6, 20 / x5 = x6 ^ 20
 
 Shift
 
 shift left logical / sll x5, x6, x7 / x5 = x6 << x7
 shift right logical / srl x5, x6, x7 / x5 = x6 >> x7
 shift right arithmetic / sra x5, x6, x7 / x5 = x6 >> x7
 shift left logical immediate / slli x5, x6, 3 / x5 = x6 << 3
 shift right logical immediate / srli x5, x6, 3 / x5 = x6 >> 3
 shift right arithmetic immediate / srai x5, x6, 3 / x5 = x6 >> 3
 
 Conditional branch
 
 branch if equal / beq x5, x6, 100 / if (x5 == x6) go to PC+100
 branch if not equal / bne x5, x6, 100 / if (x5 != x6) go to PC+100
 branch if less than / blt x5, x6, 100 / if (x5 < x6) go to PC+100
 branch if greater or equal / bge x5, x6, 100 / if (x5 >= x6) go to PC+100
 branch if less, unsigned / bltu x5, x6, 100 / if (x5 < x6) go to PC+100
 branch if greater or equal, unsigned / bgeu x5, x6, 100 / if (x5 >= x6) go to PC+100
 
 Unconditional branch
 
 jump and link / jal x1, 100 / x1 = PC + 4; go to PC + 100
 jump and link register / jalr x1, 100(x5) / x1 = PC + 4; go to x5 + 100
 </pre>
 
 C 치환문 2개의 번역<br>
 
 <pre>
 a = b + c;
 d = a - e;
 
 add a, b, c
 sub d, a, e
 </pre>
 
 복잡한 C 치환문의 번역<br>
 
 <pre>
 f = (g + h) - (i + j);
 
 add t0, g, h
 add t1, i, j
 sub f, t0, t1
 </pre>
 
 Java는 원래 이식성을 높이기 위해 소프트웨어 인터프리터를 사용하도록 설계됨.<br>
 이 인터프리터의 명령어 집합을 Java 바이트코드라고 부름.<br>
 오늘날의 Java 시스템은 Java 바이트코드를 기계어로 컴파일함.<br>
 C 프로그램보다 컴파일이 훨씬 나중에 일어나므로 이러한 Java 컴파일러를 JIT(Just In Time) 컴파일러라고 부르기도 함.<br>
 
  **:pushpin: 피연산자**
  
  산술 명령어의 피연산자에는 제약이 있음.<br>
  레지스터(register)라고 하는 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 것만을 사용할 수 있음.<br>
  RISC-V 구조에서 레지스터의 크기는 32비트임.<br>
  RISC-V에서는 32비트가 한 덩어리로 처리되는 일이 매우 빈번하므로 이것을 워드(word)라고 부름.<br>
  64비트 그룹도 자주 사용되는데 RISC-V에서는 더블워드(doubleword)라고 불림.<br>
  프로그래밍 언어에서 사용하는 변수와 하드웨어 레지스터의 큰 차이점 하나는 레지스터는 개수가 한정되어 있다는 점임.<br>
  현대 컴퓨터는 RISC-V처럼 보통 32개의 레지스터가 있음.<br>
  기호 형태로 표현된 RISC-V 언어를 하향식으로 단계적으로 구체화할 때 산술 명령어의 모든 피연산자는 32개의 32비트 레지스터 중 하나이어야 한다는 제약이 추가됨.<br>
  레지스터 개수를 32개로 제한하는 이유는 하드웨어 기술의 바탕이 되는 세 가지 설계 원칙 중 두 번째 원칙에서 찾을 수 있음.<br>
  설계 원칙 2: 작은 것이 더 빠르다.<br>
  레지스터가 아주 많아지면 전기 신호가 더 멀리까지 전달되어야 하므로 클럭 사이클 시간이 길어짐.<br>
  RISC-V의 관례는 X 뒤에 레지스터 번호를 붙이는 것임.<br>
  
  레지스터를 사용하여 C 치환문을 번역
  
  <pre>
 f = (g + h) - (i + j);
 f, g, h, i, j를 레지스터 x19, x20, x21, x22, x23에 각각 할당했다고 가정하자.
 
 add x5, x20, x21
 add x6, x22, x23
 sub x19, x5, x6
 </pre>
 
 **메모리 피연산자**<br>
 
 단순 변수 외에도 배열(array)이나 구조체(structure) 같은 복잡함 자료구조가 있음.<br>
 이런 복잡한 자료구조 하나에는 레지스터 개수보다 훨씬 많은 데이터 원소가 있을 수 있음.<br>
 컴퓨터 메모리는 수십억 개의 데이터를 저장할 수 있음.<br>
 그러므로 배열이나 구조체 같은 자료구조는 메모리에 보관함.<br>
 RISC-V 산술 연산은 레지스터에서만 실행되므로 메모리와 레지스터 간에 데이터를 주고 받는 명령어가 있어야 함.<br>
 이런 명령어를 데이터 전송(data transfer) 명령어라 함.<br>
 메모리에 기억된 데이터에 접근하려면 명령어가 메모리 주소(memory address)를 지정해야 함.<br>
 메모리는 주소가 인덱스 역할을 하는 큰 1차원 배열임.<br>
 주소는 0부터 시작함.<br>
 메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령을 적재(load)라고 함.<br>
 적재 명령은 연산자 이름과 메모리에서 읽어 온 값을 저장할 레지스터, 메모리 접근에 사용할 상수와 레지스터로 구성됨.<br>
 메모리 주소는 명령어의 상수 부분과 두 번째 레지스터 값의 합으로 구해짐.<br>
 
 메모리 피연산자를 사용하는 치환문의 번역<br>
 
 <pre>
 A는 우너소가 100개인 워드 배열이고, 시작 주소가 x22에 기억되어 있음.
 변수 g, h는 레지스터 x20, x21에 할당되어 있음.
 
 g = h + A[8];
 
 lw x9, 32(x22)
 add x20, 21, x9
 </pre>
 
 상수 부분(32)을 변위(offset)라고 함.<br>
 주소 계산을 위해 여기에 더해지는 레지스터(x22)를 베이스 레지스터라고 함.<br>
 프로그램에서 8비트로 구성된 바이트를 많이 사용하므로 대부분의 컴퓨터는 바이트 단위로 주소를 지정함.<br>
 워드 주소는 워드를 구성하는 4바이트 주소 중 하나를 사용함.<br>
 그러므로 연속된 워드의 주소는 4씩 차이가 남.<br>
 최상(big end) 바이트 주소를 워드 주소로 사용하는 컴퓨터와 제일 오른쪽, 즉 최하위(little end) 바이트 주소를 워드 주소로 사용하는 컴퓨터 두 종류가 있음.<br>
 RISC-V는 최하위 주소를 사용하는 리틀 엔디안(little endian)임.<br>
 <br>
 적재와 반대로 레지스터 내용을 메모리로 복사하는 명령을 저장(store)이라고 함.<br>
 연산자 이름, 저장할 데이터를 갖고 있는 레지스터, 베이스 레지스터, 배열 원소 선택에 사용할 변위로 구성됨.<br>
 RISC-V에서 이 명령어의 실제 이름은 sw(store word)임.<br>
 
 **고난도**<br>
 
 워드의 시작 주소는 4의 배수라야 하는 컴퓨터 구조가 많이 있음.<br>
 이러한 요구사항을 정렬제약(alignment restriction)이라 함.<br>
 정렬제약은 메모리 내에서 데이터는 자연스러운 경계를 지켜서 정렬되어야 한다는 요구사항임.<br>
 정렬을 사용하면 데이터 전송이 빨라짐.<br>
 RISC-V와 Intel x86에는 정렬제약이 없지만, MIPS에는 정렬제약이 있음.<br>
 <br>
 적재와 저장을 사용한 번역
 <pre>
 A[12] = h + A[8];
 
 lw x9, 32(x22)
 add x9, x21, x9
 sw x9, 48(x22)
 </pre>
 
 RISC-V에서 메모리와 레지스터 사이에 워드를 복사하는 명령어는 lw와 sw 2개 뿐이지만, 다른 컴퓨터에서는 적재와 저장 명령어 외에 다른 명령어들을 데이터 전송에 사용하기도 함.<br>
 Intel x86이 이런 구조임.<br>
 컴퓨터가 갖고 있는 레지스터보다 프로그램에서 사용하는 변수가 더 많은 경우가 자주 있음.<br>
 그러므로 컴파일러는 자주 사용되는 변수를 가능한 한 많이 레지스터에 넣고 나머지 변수는 메모리에 저장했다가 필요할 때 꺼내서 레지스터에 넣음.<br>
 자주 사용하지 않는(또는 한참 후에 사용할) 변수를 메모리에 넣는 것을 레지스터를 스필링(spilling)한다고 말함.<br>
 작을수록 빠르다는 원칙에 의하면 레지스터가 더 작으므로 메모리는 레지스터보다 속도가 느려야 함.<br>
 이것은 사실이며 데이터가 레지스터에 있으면 더 빨리 접근할 수 있음.<br>
 레지스터에 저장된 데이터는 메모리 데이터보다 사용하기도 편리함.<br>
 RISC-V의 산술 연산 명령은 레지스터 2개를 읽어서 연산한 다음 결과를 레지스터에 씀.<br>
 하지만 데이터 전송 명령은 피연산자 하나를 읽거나 쓰는 일만 할 뿐 데이터에 대한 연산은 하지 못 함.<br>
 레지스터는 메모리보다 접근시간이 짧고 처리량도 크므로, 레지스터에 저장된 데이터를 사용하면 시간이 절약되고 사용하기도 간편함.<br>
 뿐만 아니라 레지스터 접근은 메모리 접근보다 에너지도 적게 듬.<br>
 그러므로 좋은 성능을 얻고 에너지를 절약하기 위해서는 명령어 집합 구조가 충분한 레지스터를 제공하고 컴파일러가 레지스터를 효율적으로 사용해야 함.<br>
 32비트 데이터의 경우 레지스터가 약 200배 빠르며, 에너지 효율도 10,000배 정도 높음.<br>
 이러한 차이 때문에 캐시를 이용해서 메모리의 에너지와 성능 문제를 완화함.<br>
 
 **상수 또는 수치 피연산자**<br>
 
 <pre>
 lw x9, AddConstant4(x3) // x9 = constant 4
 add x22, x22, x9 // x22 = x22 + x9 (여기서 x9 == 4)
 </pre>
 
 x3 + AddrConstant4는 상수 4가 저장되어 있는 메모리 주소라고 가정한 것임.<br>
 적재 명령을 사용하지 않는 방법은 피연산자 중 하나가 상수인 산술 연산 명령어를 제공하는 것임.<br>
 이 상수를 수치(immediate) 피연산자라고 함.<br>
 상수 필드를 갖는 산술 명령어를 사용하면 매번 메모리에서 상수를 가져오는 것보다 연산이 훨씬 빨라지고 에너지를 덜 소모하게 됨.<br>
 상수 중에서도 0은 또 다른 역할이 있음.<br>
 명령어에 여러 가지 유용한 변형을 제공함으로써 명령어 집합을 단순하게 하는 것임.<br>
 예를 들어 첫 번째 피연산자가 0인 sub 명령어를 사용하면 레지스터 값의 부호를 바꿀 수 있음.<br>
 그래서 RISC-V는 레지스터 X0의 값이 0으로 고정되도록 회로를 구현함.<br>
 높은 사용 빈도를 근거로 상수를 명령어에 포함시킨 것은 자주 쓰이는 것을 빠르게 하라는 아이디어의 예임.<br>
 칩 내 레지스터 개수가 증가하는 속도는 매우 느림.<br>
 프로그램은 보통 컴퓨터 언어의 형태로 배포되므로 명령어 집합 구조에는 일종의 관성이 있음.<br>
 따라서 레지스터 개수는 새로운 명령어 집합이 실용화되는 속도만큼이나 느리게 증가함.<br>
 여기서 나오는 RISC-V는 레지스터 크기가 32비트이지만, 그 외에도 몇 가지 RISC-V ISA가 있음.<br>
 이 책에서 사용하는 건 RV32인데, 64비트 레지스터를 사용하는 RV64도 있음.<br>
 RV64는 주소가 크므로 서버와 스마트폰용 프로세서에 더 적합함.<br>
 
 **고난도**<br>
 
 원래 데이터 전송 명령은 레지스터가 배열의 인덱스를 갖고, 변위가 배열의 시작 주소를 갖도록 설계됨.<br>
 따라서 베이스 레지스터를 인덱스 레지스터라고 부르기도 함.<br>
 하지만 오늘날에는 메모리가 매우 크고 데이터 할당을 위한 소프트웨어 모델이 훨씬 복잡하여 배열의 시작 주소가 변위 부분에 다 들어가지 않으므로 레지스터에 넣는 것이 일반적임.<br>
 32비트 주소 컴퓨터에서 64비트 주소 컴퓨터로 넘어가면서 컴파일러 작성자들은 C언어 데이터 타입의 크기를 정해야 하는 문제를 안게 됨.<br>
 한 데이터 타입을 다른 데이터 타입으로 변환할 때 100% 표준에 부합하는 C코드가 아닐 경우 예기치 못한 오버플로가 발생함.<br>
 <pre>
 Microsoft Windows pointers(64) int(32) long int(32) long long int(64)
 Linux, Most Unix pointers(64) int(32) long int(64) long long int(64)
 </pre>
 
**:pushpin: 부호있는 수와 부호없는 수**
 
 어떤 기수의 숫자에서 i번째 숫자 d의 값은 d * Base^i와 같음.<br>
 여기서 i는 0에서 시작해서 왼쪽으로 갈수록 증가함.<br>
 이 방식으로 워드 내의 비트에 번호를 붙일 수 있음.<br>
 그 비트에 해당하는 기수의 거듭제곱수를 번호로 사용함.<br>
 1011two는 (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (1 * 2^0)tem = 11ten임.<br>
 가장 오른쪽, 왼쪽 비트라고 말하는 것이 모호할 수 있어서 LSB(Least Significant bit), MSB(Most Significant bit)라고 부름.<br>
 RISC-V 워드의 길이는 32비트이므로 2^32가지의 서로 다른 32비트 패턴을 표현할 수 있음.<br>
 이 조합이 0부터 2^32-1(4,294,967,295tem)까지의 숫자를 표시하게 해줌.<br>
 00000000 00000000 00000000 00000000two = 0ten<br>
 ...<br>
 11111111 11111111 11111111 11111111two = 4,294,967,295ten<br>
 32비트 이진수는 비트값과 2의 제곱수를 곱한 값으로 표현할 수 있음.<br>
 (x31 * 2^31) + (x30 * 2^30) + ... + (x1 * 2^1) + (x0 * 2^0)<br>
 
 **하드웨어/소프트웨어 인터페이스**<br>
 
 오버플로: 연산의 결과가 레지스터에서 표현될 수 있는 수보다 클 때.<br>
 양수와 음수를 구별하는 표현 방법이 필요해서 나온 것 중 하나가 부호와 크기(sign and magnitude) 표현법임.<br>
 부호와 크기 표현법은 몇 가지 단점이 있음.<br>
 첫 째, 어디에 부호 비트를 붙여야 하는지가 명확하지 않음.<br>
 둘 째, 부호와 크기 표현법의 덧셈기는 부호를 결정하기 위해 한 단계가 더 필요함. 왜냐하면 최종 부호가 무엇이 될지를 미리 알 수 없기 때문임.<br>
 마지막으로 부호 비트가 따로 붙기 때문에 양의 0과 음의 0을 가짐.<br>
 이런 단점들 때문에 부호와 크기 표현법은 잘 쓰지 않게 됨.<br>
 
 **2의 보수(two's complement) 표현법**
 <pre>
 0이 앞에 나오면 양수이고, 1이 앞에 나오면 음수임.<br>
 00000000 00000000 00000000 00000000two = 0ten<br>
 00000000 00000000 00000000 00000001two = 1ten<br>
 ...<br>
 01111111 11111111 11111111 11111111two = 2,147,483,647ten<br>
 10000000 00000000 00000000 00000000two = -2,147,483,648ten<br>
 10000000 00000000 00000000 00000000two = -2,147,483,647ten<br>
 ...<br>
 11111111 11111111 11111111 11111110two = -2ten<br>
 11111111 11111111 11111111 11111111two = -1ten<br>
 </pre>
 2의 보수 표현에서 모든 음수는 MSB가 1이라는 장점이 있음.<br>
 따라서 하드웨어가 양수인지 음수인지 알아보려면 MSB만 검사하면 됨.(0은 양수 취급)<br>
 그러므로 MSB를 부호 비트라고 부름.<br>
 부호 비트의 역할을 이해하면, 비트값에 2의 거듭제곱수를 곱한 값으로 32비트의 양수와 음수를 모두 표현할 수 있음.<br>
 (x31 * -2^31) + (x30 * 2^30) + ... + (x1 * 2^1) + (x0 * 2^0)<br>
 2의 보수 연산에서도 오버플로가 발생함.<br>
 무한히 많은 비트 수로 표현한다면 왼쪽에 무수히 나타날 비트와 실제 이진 비트 패턴의 왼쪽 비트가 서로 다를 때(즉, 부호 비트가 틀렸을 때) 오버플로가 발생한 것임.<br>
 <br>
 부호있는 수와 부호없는 수는 산술 연산뿐만 아니라 적재 명령어와도 상관이 있음.<br>
 부호있는 적재의 기능은 레지스터의 남는 곳을 채우기 위해 부호를 반복하여 복사하는 것임.(부호확장, sign extension)<br>
 그 목적은 레지스터 내에 숫자의 정확한 표현을 넣는 것임.<br>
 부호없는 적재의 경우에는 단순히 데이터의 왼쪽을 0으로 채우면 됨.<br>
 이 비트 패턴이 표현하는 수에는 부호가 없기 때문임.<br>
 32비트 레지스터에 32비트 워드를 적재할 경우에는 부호있는 적재와 부호없는 적재가 동일함.<br>
 lbu(load byte unsigned) 명령어는 바이트를 부호없는 수로 간주하고 남은 24비트를 0으로 채움.<br>
 lb(load byte) 명령어는 바이트를 부호있는 정수로 간주하여 부호확장한 후 레지스터를 채움.<br>
 C프로그램의 바이트는 대부분의 경우 매우 짧은 부호있는 정수보다는 문자를 표시하는데 사용되므로, 바이트 적재에 실제로는 lbu 명령어만 사용됨.<br>
 메모리 주소는 자연스럽게 0에서부터 시작해 가장 큰 주소까지 이어짐. 음수 주소는 의미가 없음.<br>
 따라서 프로그램이 양수도 될 수 있고, 음수도 될 수 있는 수를 다루기를 원할 때도 있고, 양수값만 찾는 수를 다루고자 할 때도 있음.<br>
 C언어에서 전자를 정수(int)라고 하고, 후자를 부호없는 정수(unsinged int)라고 함.<br>
 
 **2의 보수 연산**<br>
 빠른 부호 바꾸기 방법은 모든 0은 1로, 1은 0으로 바꾼 뒤 1을 더하는 것임.<br>
 이는 원래 수와 모든 비트를 역전시킨 수의 합이 -1이라는 것에 기초하고 있음.<br>
 x + xbar = -1이므로 x + xbar + 1= 0임.<br>
 빠른 부호확장 방법은 n비트로 표현된 이진수를 n비트보다 긴 수로 바꾸는 방법임.<br>
 짧은 이진수의 최상위 비트를 취해서 비어 있는 왼쪽 부분에 채우고, 원래의 n비트 값은 긴 수의 오른쪽 부분에 그대로 복사하는 것임.<br>

 컴퓨터 워드에 양수와 음수를 모두 나타낼 필요가 있음.<br>
 여러가지 방식이 제안되어 왔지만 1965년 이후에는 2의 보수 표현법으로 통일됨.<br>
 
 부호있는 십진수는 크기에 대한 제한 사항이 없기 때문에 음수를 표현하기 위해 -를 사용함.<br>
 하지만 이진수와 16진수 비트열은 고정된 워드 크기 내에서 부호를 표시할 수 있으므로 일반적으로 +나 -를 사용하지 않음.<br>
 
 **다양한 표현법**<br>
 
 2의 보수법이란 이름은 n비트의 수와 그 음수의 합을 부호없는 수로 나타내면 2^n이 된다는 법칙에서 비롯됨.<br>
 x + x보수 = 2^n이므로 x보수 = 2^n - x임.<br>
 1의 보수 표현법은 비트의 0과 1을 맞바꾸어서 음수를 만들 수 있으며, x의 보수는 2^n - x - 1임.<br>
 1의 보수 표현법은 0이 두 가지로 표현되는 것을 제외하면 2의 보수법과 비슷함.<br>
 00...00two는 양의 0이고, 11...11two는 음의 0임.<br>
 가장 작은 음수 10...00two는 -2,147,483,647ten을 나타내며, 따라서 양수와 음수의 개수는 같음.<br>
 마지막 표현법은 절대값이 가장 큰 음수를 00...00two로 표현하고, 가장 큰 양수는 11...11two로 표현하며, 0은 10...00two로 표현하는 방식임.<br>
 이 표현을 부동 소수점을 다룰 때 보게됨.<br> 
 숫자에 바이어스 값을 더하여 항상 양수로 표현하기 때문에 이 방식을 바이어스된 표현법(biased notation)이라고 함.<br>
 
  **:pushpin: 명령어의 컴퓨터 내부 표현**
  
  실제로 명령어의 각 부분을 숫자로 볼 수 있으며, 이 숫자들을 나란히 늘어놓으면 명령어가 됨.<br>
  add x9, x20, x21은 0 / 21 / 20 / 0 / 0 / 51임.<br>
  명령어의 각 부분을 필드(field)라고 부름.<br>
  1, 4, 6번째 필드는 
 
 
**:pushpin: 문자와 문자열**
 
 오늘날 대부분의 컴퓨터는 8비트 바이트로 문자를 표현하며, 거의 모든 컴퓨터가 ASCII(American Standard Code for Information Interchange)를 사용함.<br>
 명령어 몇 개를 사용하면 워드 내의 특정 바이트를 추출할 수 있음.<br>
 그러므로 적재 명령어 lw와 저장 명령어 sw는 워드뿐 아니라 바이트 전송에도 사용될 수 있음.<br>
 하지만 효율성을 위해 RISC-V에는 바이트 전송 명령어가 따로 있음.<br>
 lbu(load byte unsigned)는 메모라에서 한 바이트를 읽어서 레지스터의 오른쪽 8비트에 채우는 명령임.<br>
 sb(store byte)는 레지스터의 오른쪽 8비트를 메모리로 보내는 명령어임.<br>
 한 바이트를 복사할 때는 다음과 같이 할 수 있음.<br>

 <pre>
 lbu x12, 0(x10) //Read byte from source
 sb x12, 0(x11) //Write byte to destination
 </pre>
 
 문자 데이터는 보통 여러 개가 모여서 문자열(string)을 이루는데, 문자열의 길이는 가변적임.<br>
 가변 길이의 문자열을 표현하는 방법에는 세 가지가 있음.<br>
 첫 째, 맨 앞에 길이를 표시하는 방법.<br>
 둘 째, 같이 사용되는 변수에 그 길이를 표시하는 방법.<br>
 마지막, 문자열의 끝을 표시하는 특수 문자를 두는 방법.<br>
 C 언어는 문자열의 끝에 0값(ASCII의 null)을 두는 세 번째 방법을 사용함.<br>
 그러므로 Cal은 67, 97, 108, 0의 네 바이트로 표현됨.<br>
 JAVA는 첫 번째 방법을 사용함.<br>
  
<pre>  
strcpy:                   // strcpy 함수 시작점을 나타냄
  addi sp, sp, -4         // 스택 포인터 조정: 스택 포인터를 4바이트 감소시켜 스택 공간을 할당함. 이는 함수 내에서 스택 메모리를 사용하기 위한 작업임.
  sw x19, 0(sp)          // 현재 레지스터 x19에 저장된 값을 스택 메모리 가장 상위에 있는 메모리 공간에 저장함. 이는 나중에 함수에서 x19 레지스터의 값을 복원하기 위한 작업임.
  add x19, x0, x0        // i = 0 + 0 (i를 0으로 초기화), x19 레지스터에 0을 저장함.
  
L1:                      // 반복문 시작
  add x5, x19, x11       // x11은 배열 y의 시작 주소를 가리키고, x19는 현재 i값을 가지고 있음. 따라서 y[i]의 주소를 계산하여 x5에 저장함.
  lbu x6, 0(x5)          // y[i] 값을 로드하여 x6에 저장
  add x7, x19, x10       // x10은 배열 x의 시작 주소를 가리키고, x19는 현재 i값을 가지고 있음. 따라서 x[i]의 주소를 계산하여 x7에 저장함.
  sb x6, 0(x7)           // x[i]에 y[i] 값을 저장함. sb는 바이트 단위로 값을 저장하는데, 이는 값이 부호 없는 문자임을 가정하기 때문임.
  beq x6, x0, L2         // y[i]가 NULL이면 (0이면) 복사 작업이 끝났으므로 L2로 점프
  addi x19, x19, 1       // i = i + 1
  jal x0, L1             // L1로 점프하여 반복함. 이는 다시 y[i+1] 값을 읽어 x[i+1]에 저장하기 위함임.
  
L2:                      // 반복문 종료
  lw x19, 0(sp)          // 스택에서 x19에 저장된 값을 로드하여 복원
  addi sp, sp, 4         // 스택 포인터 조정: 스택에서 4바이트 크기의 공간을 해제하여 사용
  jair x0, 0(x1)         // strcpy 함수에서 호출된 함수로 되돌아감. 이는 함수 호출 이전 상태로 프로그램 카운터를 복원하는 역할을 함.
</pre>

스택 포인터: 메모리에서 현재 사용 중인 스택의 맨 위에 위치하는 메모리 주소를 가리키는 레지스터임.<br>
레지스터: CPU 내부에 있는 소규모 메모리 공간으로, CPU가 자주 액세스하는 데이터를 저장함.<br>
add: 주어진 레지스터의 값을 더하여 결과를 저장함.<br>
 
 프로시저 strcpy는 말단 프로시저이므로 컴파일러가 i를 임시 레지스터에 할당했으면 x19를 저장하고 복구하는 일을 피할 수도 있었음.<br>
 그러므로 임지 레지스터들을 단순히 임시용으로 생각하지 말고, 피호출 프로그램이 편리할 때 사용하는 레지스터로 생각하는 것이 좋음.<br>
 실제로 컴파일러가 말단 프로시저를 만나면 우선 이런 임시 레지스터들을 쓰고 부족하면 그 때 저장해야 하는 레지스터를 사용함.<br>
 
 **JAVA의 문자와 문자열**<br>
 유니코드(Unicode)는 인간이 사용하는 거의 모든 언어의 자모(alphabet)를 수용할 수 있는 범용 인코딩임.<br>
 유니코드에는 ASCII의 기호만큼이나 많은 자모가 있음.<br>
 Java는 포괄성을 위해 문자를 유니코드로 표현함.<br>
 그러므로 문자 표현에 16비트를 사용하는 것이 디폴트임.<br>
 RISC-V 명령어 집합에는 하프워드라 불리는 16비트 데이터에 대한 적재와 저장 명령어가 포함되어 있음.<br>
 lhu(load half unsigned) 명령은 메모리에서 비트를 읽어 와서 레지스터의 우측 16자리에 넣음.<br>
 왼쪽 16비트는 0으로 채움.<br>
 lb처럼 lh(load half)도 하프워드를 부호있는 수로 취급하므로, 레지스터의 왼쪽 비트를 부호 확장하여 채움.<br>
 sh(store half)는 레지스터의 우측 16비트를 메모리에 씀.<br>
 다음과 같이 하면 하프워드를 복사할 수 있음.<br>
 
 <pre>
 lhu x19, 0(x10) // Read halfword(16 bits) from source
 sh x19, 0(x11) // Write halfword (16 bits) to destination
 </pre>

 문자열은 내장된 특별 지원 기능과 사전 정의된 연접, 비교, 변환 메소드를 가지고 있는 표준 Java 클래스임.<br>
 C와 달리 java 문자열은 길이를 나타내는 워드를 포함하고 있음.<br>
 RISC-V 소프트웨어는 스택을 "쿼드워드(16바이트)" 주소에 맞춰 정렬함.<br>
 16바이트면 충분한 char 변수도 스택에 저장할 때는 16바이트를 할당함.<br>
 그러나 C 문자열 변수나 바이트 배열은 한 쿼드워드에 16바이트씩 묶어서 넣음.<br>
 JAVA의 문자열 변수나 short 배열은 한 쿼드워드에 8개의 하프워드씩 넣음.<br>
 웹은 국제적이라는 특성이 있기 때문에 이를 반영하여 대부분의 웹 페이지들은 ASCII 대신에 Unicode를 사용함.<br>
 따라서 오늘날에는 ASCII보다 Unicode가 더 인기있음.<br>

 **:pushpin: 추가**<br>

Intel IA32는 인텔이 1985년에 처음으로 출시한 32비트(x86) 아키텍처임.<br>
이 아키텍처는 32비트 모드에서만 동작하며, 최대 4GB의 메모리를 지원함.<br>
이제는 더 이상 사용되지 않음.<br>
X86-64(인텔 64 또는 AMD64)는 64비트(x86) 아키텍처임.<br>
인텔과 AMD가 공동으로 개발하였으며, IA32와의 하위 호환성을 제공함.<br>
그러므로 기존에 IA32용으로 작성된 소프트웨어도 X86-64에서 동작할 수 있음.<br>
이 아키텍처는 IA32와 비교하여 더 많은 메모리를 지원하며, 더 많은 레지스터와 SIMD(Single Instruction Multiple Data) 명령어 등을 지원함.<br>
현재 대부분의 컴퓨터에서는 X86-64 아키텍처를 사용하고 있음.<br>
 x86은 Intel 사의 8086 마이크로프로세서를 기반으로 한 CPU 아키텍처의 이름임.<br>
 x86 아키텍처는 Intel이 개발했지만, AMD, VIA 등의 다른 회사들도 호환성을 유지하면서 x86 아키텍처를 사용하는 CPU를 제조하고 있음. 따라서 x86 아키텍처는 PC 시장에서 가장 일반적으로 사용되는 아키텍처 중 하나임.<br>

<pre>
$ wc p24.c
</pre>

현재 디렉토리에서 p24.c 파일의 라인 수, 단어 수, 문자 수를 출력함. 즉 파일의 크기를 출력함.<br>

<pre>
$ gcc -E p24.c > p24.pp.c
</pre>

C언어로 작성된 p24.c 파일을 전처리하여 p24.pp.c 파일에 출력함.<br>
전처리 과정은 #include나 #define과 같은 전처리 지시문들을 처리하고, 매크로를 풀어 표준 C코드로 변환하는 등의 작업을 수행함.<br>

<pre>
$ gcc -- version
gcc (Gentoo 12.2.1_p20230121-r1 p10) 12.2.1 20230121
</pre>

gcc --version은 현재 시스템에서 설치된 GCC 컴파일러의 버전 정보와 함께 GCC를 빌드한 날짜와 시간, 사용된 GCC 구성 옵션 등의 정보를 출력함.<br>
이 경우 Gentoo 리눅스 배포판의 GCC 버전인 12.2.1_20230121-r1을 사용하고 있음.<br>

<pre>
$ vi p24.pp.c
</pre>

p24.pp.c를 vi 편집기로 열어 해당 파일의 내용을 편집하고자 함.<br>

<pre>
$ gcc -S p24.pp.c
</pre>

p24.pp.c를 gcc 컴파일러에게 제공하여, 해당 파일의 어셈블리 코드 파일을 생성하도록 지시하는 명령어임.

<pre>
$ gcc -c p24.pp.s
</pre>

어셈블리 코드 파일(p24.pp.s)을 컴파일하여 오브젝트 파일을 생성하는 명령어임.<br>
이 명령어를 실행하면 p24.pp.o와 같은 오브젝트 파일이 생성됨.

<pre>
$ hexdump -x p24.pp.o
</pre>
p24.pp.o 파일의 16진수 형태로 파일 내용을 출력하는 명령어임.<br>
이 명령어를 사용해서 오브젝트 파일의 내용을 16진수로 출력하여, 파일 내용을 더 자세히 살펴볼 수 있음.<br>
-x는 16진수 출력을 지정하는 옵션임. 이 명령어를 실행하면, 파일 내용이 16진수 형태로 출력도되며, 각각 16비트(2바이트)씩 끊어서 출력됨.

<pre>
$ gcc -o p24 p24.pp.o
</pre>

p24.pp.o를 컴파일하여 실행 파일을 생성하는 명령어임.<br>
-o는 생성할 실행 팡리의 이름을 지정하는 명령어임.<br>

<pre>
$ ls -lrt
</pre>

현재 디렉토리에 있는 파일 목록을 시간순으로 정렬하여 출력하는 명령어임.<br>
-l은 자세한 파일 정보를 출력하도록 지정하며, -r은 역순으로 정렬하도록 지정함.<br>
$ gcc -o p24 p24.pp.o와 결합하면 p24 실행파일이 생성된 후에, 파일 목록을 역순으로 정렬하여 출력함. 이를 통해 p24 실행 파일이 가장 최근에 생성된 파일임을 확인할 수 있음.
 
 <pre>
 $ readelf -a p24
 </pre>

 p24 실행파일의 ELF(Executable and Linkable Format) 헤더 및 섹션 헤더, 심볼 테이블, 다이나믹 타입 등의 정보를 출력하는 명령어임.<br>
 ELF는 리눅스와 유닉스 계열의 운영체제에서 사용되는 실행 파일 형식임.<br>
 이 명령어를 실행하면 p24 실행 파일의 구조와 세부 정보를 확인할 수 있음.<br>
 
 <pre>
 $ objdump -d p24
 </pre>
 
 p24 실행 파일의 어셈블리 코드를 출력하는 명령어임.<br>
 -d 옵션은 어셈블리 코드를 출력하도록 지정하는 옵션임.<br>
 
 **Compiler와 Run time system**<br>
 
 프로그램이 실행되는 동안 사용되는 데이터는 다양한 유형으로 분류될 수 있음.<br>
 이러한 데이터는 일반적으로 컴퓨터의 메모리에 저장되며, Compiler와 Run time system은 데이터의 유형에 따라 메모리의 적절한 위치에 할당하고 제어함.<br>
 
 Compiler는 소스 코드를 번역하여 목적 코드를 생성함.<br>
 이 과정에서 Compiler는 프로그램에서 사용되는 모든 변수, 상수, 함수 등의 메모리 요구 사항을 분석함.<br>
 이 정보는 목적 코드와 함께 Object 파일로 저장되며, Run time system이 이 정보를 사용하여 프로그램을 실행할 때 필요한 메모리를 할당함.<br>
 
 Run time system은 운영 체제로부터 할당 받은 메모리를 사용하여 프로그램의 데이터를 저장함. 이 메모리는 주로 두 가지 유형으로 구분됨.<br>
 Stack 메모리 : 함수 호출과 관련된 데이터, 지역 변수 및 매개 변수를 저장하는 데 사용됨. Stack 메모리는 Run time system에 의해 자동으로 할당 및 해제되며, 함수 호출이 완료될 때 스택에서 제거됨.<br>
 Heap 메모리 : 프로그램에서 동적으로 할당되는 데이터, 즉 사용자가 필요에 따라 메모리를 동적으로 할당하는 경우 사용됨. 예를 들어, 프로그램이 실행 중에 사용자가 새로운 객체를 생성하는 경우, 객체의 데이터가 Heap 메모리에 저장됨. Heap 메모리는 Run time system에 의해 수동으로 할당 및 해제되며, 이를 관리하기 위해 동적 메모리 할당 라이브러리가 사용됨.<br>
 또한, Run time system은 전역 변수와 상수를 저장하는 데이터 섹션 및 프로그램 코드를 저장하는 텍스트 섹션 등의 다른 메모리 영역도 관리함. 이러한 메모리 영역은 Compiler가 생성한 목적 코드와 함께 실행 파일에 저장되며, Run time system은 이를 메모리에 로드하여 프로그램을 실행함.<br>
 
 **Disassembly**<br>
 
 Disassembly는 컴퓨터 프로그램의 바이너리 코드를 읽고 해석하여 어셈블리 코드로 변환하는 과정을 말함.<br>
 즉, 컴퓨터가 직접 실행할 수 있는 기계 코드로 작성된 프로그램을 사람이 이해할 수 있는 언어로 변환하는 작업을 말함.<br>


  <h2><a id="3">:pencil2: Chapter3. 컴퓨터 연산</a></h2>
 
 **:pushpin: 덧셈과 뺄셈**
 
 연산 결과를 사용 가능한 하드웨어(예를 들어 32비트)로 표현할 수 없을 때 오버플로가 발생함.<br>
 덧셈에서는 부호가 다른 피연산자를 더할 경우에는 오버플로가 발생하지 않음.<br>
 계산 결과의 절대값이 두 피연산자 중 어느 하나보다는 커질 수 없기 때문임.<br>
 뺄셈에서는 반대로 피연산자의 부호가 같을 때 오버플로가 발생하지 않음.<br>
 같은 부호의 수를 빼는 것은 부호가 다른 수를 더하는 것과 같기 때문임.<br>
 32비트 수 2개를 더하거나 뺀 결과를 완벽하게 표현하기 위해서는 33비트가 필요할 경우가 있음.<br>
 워드 크기가 32비이므로 33번째 비트는 표시할 수 없는데, 이렇게 되면 부호 비트가 결과의 부호가 아니라 크기를 나타내는 비트 중 최상의 비트값으로 결정됨.<br>
 따라서 두 양수를 더한 값이 음수가 되면 오버플로가 발생한 것임.<br>
 두 음수를 더했는데 하비 양수가 되는 경우에도 오버플로가 발생한 것임.<br>
 부호없는 정수는 오버플로가 무시되는 메모리 주소에 사용됨.<br>
 컴파일러는 분기 명령어를 사용하여 부호없는 오버플로를 쉽게 검사할 수 있음.<br>
 덧셈에서는 합이 더해지는 두 수 중 어느 하나보다 작으면 오버플로가 발생한 것이고, 뺄셈에서는 그 차이가 피감수보다 더 크면 오버플로가 발생한 것임.<br>
 예를 들어 부호 없는 정수 01100100(100) - 11001000(200) = 10011100(156)인데, 결과값이 피감수보다 크기 때문에 오버플로가 발생한 것임.<br>
 <br>
 
 산술논리연산장치(ALU, Arithmetic Logic Unit)은 덧셈과 뺄셈을 수행하는 하드웨어로 AND와 OR 같은 논리 연산을 수행함.<br>
 C나 Java 같은 언어들은 정수 오버플로를 무시하지만, Ada나 Fortran 같은 언어는 프로그램에게 알려지기를 요구함.<br>
 어떤 프로그래밍 언어는 바이트나 하프워드로 선언된 변수에 대해서도 2의 보수법 정수 연산을 허용하지만, RISC-V는 32비트 워드에 대해서만 정수 연산을 허용함.<br>
 RISC-V에 바이트와 하프워드 데이터 전송 명령은 있음.<br>
 lb/lh를 이용하여 적재하고, add/sub/mul/div로 연산하고, and로 결과를 마스크(mask)하여 8비트나 16비트로 만든 후, sb/sh를 이용하여 저장함.<br>
 혹은 lb/lh를 이용하여 적재하고, add/sub/mul/div로 연산한 후, sb/sh를 이용하여 저장함.<br>
 포화(saturating) 연산이 있는데, 오버플로가 발생했을 때 2의 보수 산술이 모듈로 연산을 하는 것과 달리 포화는 가장 큰 양수나 음수를 결과값으로 함.<br>
 예를 들어 라디오의 볼륨 손잡이를 계속 돌릴 때, 포화 기능을 사용하면 손잡이를 아무리 돌려도 가장 큰 음량에서 더 이상 변하지 않음.<br>
 덧셈의 속도는 상위 비트들로 올라가는 올림수를 얼마나 빨리 계산하는가에 의존함.<br>
 이를 위해 올림수를 예측해서 최악의 경우 덧셈기 비트 수만큼이 아니라 덧셈기 비트 수의 log2 함수로 올림수를 계산할 수 있는 여러 가지 방법이 제안되어 왔음.<br>
 이를 위해 예측 신호는 더 적은 수의 게이트를 통과하기 때문에 빠르기는 하지만 올림수를 예측하기 위해서 더 많은 게이트를 필요로 함.<br>
 가장 널리 사용되는 방식은 올림수 예견(carry lookahead) 기법임.<br>
 
 **Carry Look Ahead Adder**<br>
 
 Ripple Carry Adder는 carry 값이 아랫자리 수부터 파동치며 올라와 마지막 full adder의 Cin으로 값이 들어와야만 carry의 값이 구해지므로 시간 낭비가 있음.<br>
 CLA는 generate와 propagate 두 가지의 신호로 이루어져 있고, Gi = Ai * Bi, Pi = Ai + Bi로 정의됨.<br>
 Ci = AiBi + (Ai + Bi)Ci = Gi + PiCi로 나타낼 수 있음.<br>
 C1 = G0 + P0Cin<br>
 C2 = G1 + P1C1 = G1 + P1(G0 + P0Cin) = G1 + P1G0 + P0P1Cin<br>
 C3 = G2 + P2C2 = G2 + P2(G1 + P1G0 + P0P1Cin) = G2 + P2G1 + P2P1G0 + P2P1P0Cin<br>
 Cout = G3 + P3C3 = G3 + P3(G2 + P2G1 + P2P1G0 + P2P1P0Cin) = G3 + P3G2 + P3P2G1 + P3P2P1G0 + P3P2P1P0Cin<br>
 이전 값의 계산을 기다리지 않아도 바로 C를 구할 수 있음.<br>
 
 **:pushpin: 곱셈**
 
 1000ten * 1001ten = 1001000ten인데 1000ten을 피승수, 1001ten을 승수, 1001000ten을 곱이라고 함.<br>
 부호 비트를 무시하면 n비트의 피승수에 대한 m비트 승수의 곱셈 결과는 n + m 비트의 길이를 갖음.<br>
 결국 모든 가능한 곱을 표현하기 위해서는 n + m 비트가 필요함.<br>
 덧셈과 마찬가지로 곱셈에도 오버플로 문제가 있음.<br>
 
 **곱셈 알고리즘과 하드웨어의 순차적 버전**<br>
 
 피승수(Multiplicand) 레지스터, ALU, 곱(Product) 레지스터는 모두 64비트이고, 승수(Multiplier) 레지스터만 32비트임.<br>
 시작할 때는 32비트 피승수가 피승수 레지스터의 오른쪽 절반에 있따가 매 단계마다 왼쪽으로 1비트씩 자리 이동함.<br>
 승수는 매 단계마다 반대방향으로 자리이동함.<br>
 알고리즘은 곱 레지스터를 0으로 초기화하고 시작됨.<br>
 제어는 피승수 레지스터와 승수 레지스터를 언제 자리이동할지, 또 새로운 값을 언제 곱 레지스터에 쓸지를 결정함.<br>
 승수의 최하위 비트(Multiplier0)는 피승수를 곱 레지스터에 더할지 말지 결정함.<br>
 <br>
 단계 1: Multiplier0을 검사함. 1이면 Multiplicand를 product에 더하고, 그 결과를 Product register에 위치시킴. 0이면 넘어감.<br>
 단계 2: Multiplicand register를 왼쪽으로 1비트 옮김.<br>
 단계 3: Multiplier register를 오른쪽으로 1비트 옮김.<br>
 32번째 반복한 것이라면 끝내고, 그렇지 않으면 단계 1로 넘어감.<br>
 
각 단계에 한 클럭 싸이클씩 필요하다면 이 알고리즘은 32비트 숫자 2개를 곱하는데 거의 200 클럭 사이클이 걸림.<br>
덧셈과 뺄셈의 사용 빈도는 곱셈의 5배에서 100배 사이쯤임.<br>
따라서 많은 응용 프로그램에서 곱셈은 여러 클럭 사이클이 걸려도 성능에 큰 영향을 끼치지 않음.<br>
 이 알고리즘과 하드웨어는 매 반복이 1클럭 사이클만 걸리도록 쉽게 바꿀 수 있음.<br>
 연산을 병렬로 수행함으로써 이러한 속도 향상이 가능해짐.<br>
 승수 비트가 1일 때 피승수를 곱에 더하는 동안 승수와 피승수를 자리이동함.<br>
 이 때 하드웨어가 검사하는 승수의 맨 오른쪽 비트가 자리이동하기 전의 값이고 덧셈에 사용하는 값이 전 반복에서 자리이동된 피승수인 것만 확실하게 하면 문제없음.<br>
 덧셈기와 레지스터에서 사용되지 않는 부분이 있으므로 덧셈기와 레지스터의 폭을 절반으로 줄여 더욱최적화 할 수도 있음.<br>
 이 경우네는 피승수 레지스터와 ALU를 32비트로 줄임.<br>
 이번에는 곱이 오른쪽으로 자리이동됨.<br>
 별도의 승수 레지스터는 없어짐.<br>
 대신 승수를 곱 레지스터의 오른쪽 절반에 넣음.<br>
 승수 레지스터는 덧셈기의 올림수를 저장할 수 있도록 65비트가 됨.<br>
 거의 모든 컴파일러는 2의 거듭제곱으로 곱하는 것을 왼쪽 자리이동으로 대치하는 강도 감소 최적화(strength reduction optimization)을 수행함.<br>
 
 **부호있는 곱셈**<br>
 
 부호있는 수의 곱셈을 가장 쉽게 이해할 수 있는 방법은 먼저 승수와 피승수를 양수로 변환하고 원래의 부호를 기억하는 것임.<br>
 이 알고리즘은 부호를 계산에서 제외시키고 31번 반복한 후, 피연산자들의 부호가 서로 다를 때만 곱을 음수로 바꿈.<br>
 부호있는 수의 경우에는 자리이동 단계에서 곱의 부호를 확장해야 함.<br>
 부호 비트를 유지하기 위해 최상위 비트를 제외한 나머지 비트들만 이동시키고, 마지막 자리 이동에서는 최상위 비트도 함께 이동시킴.<br>
 이 때, 최상위 비트를 이동시키는 경우에는 부호를 유지하기 위해 최상위 비트와 그 아래 비트들을 동시에 이동시킴.<br>
 알고리즘이 끝나면 아래쪽 워드에 32비트 곱이 남게 됨.<br>
 부호있는 수의 곱셈에서 결과값이 64비트가 되기 때문임.<br>
 64비트이므로 이를 32비트 워드 두 개로 분할하여 저장함.<br>
 이 때, 상위 32비트와 하위 32비트를 분리하여 저장함.<br>
 
 **더 빠른 곱셈**<br>
 
 곱셈을 시작하는 초기에 승수의 32개 비트를 한꺼번에 조사하면 피승수가 더해져야 하는지 아닌지를 바로 알 수 있음.<br>
 그러므로 승수의 매 비트마다 32비트 덧셈기를 하나씩 할당하면 더 빠른 곱셈이 가능함.<br>
 이 덧셈기의 입력 하나는 피승수를 해당 승수 비트와 AND한 것이고 다른 입력은 앞 덧셈기의 출력임.<br>
 32번의 덧셈을 병렬 트리 구조로 만들 수도 있음.<br>
 이렇게 하면 32번의 덧셈 시간을 기다리는 대신에 log5(32) = 5번의 덧셈 시간만 기다리면 됨.<br>
 **올림수 저장 덧셈기(carry save adder)을 사용할 수도 있고, 이러한 설계를 파이프라인화 해서 다수의 곱셈을 동시에 수행할 수 있게 하는 것이 쉽기 때문에, 실제로는 여섯 번의 덧셈 시간보다 더 빨라질 수 있음.**<br>
 
 **RISC-V에서의 곱셈**<br>
 
 RISC-V는 mul(multiply), mulh(multiply high), mulhu(multiply high unsigned), mulhsu(multiply high signed-unsinged)의 네 가지 명령어를 사용하여 부호있는 또는 부호없는 64비트 곱을 구함.<br>
mul 명령어를 32비트 곱을 얻기 위해서 사용됨.<br>
mulh는 64비트 곱에서 상위 32비트를 얻기 위해서 사용되고, 두 피연산자가 모두 부호가 있는 경우임.<br>
mulhu는 64비트 곱에서 상위 32비트를 얻기 위해서 사용되고, 두 피연산자가 모두 부호가 없는 경우임.<br>
mulhsu는 한 피연산자는 부호가 있고, 다른 피연산자는 부호가 없는 경우임.<br>
32비트 곱셈에서 오버플로를 검사하기 위해 multiply high를 활용할 수도 있음.<br>
32비트 부호없는 곱셈의 경우 mulhu 결과가 0이면 오버플로가 없는 것임.<br>
32비트 부호있는 곱셈의 경우 mulh의 결과의 모든 비트가 mul 결과의 부호 비트와 같으면 오버플로가 없는 것임.<br>
 
 **:pushpin: 나눗셈**
 
 나눗셈의 피연산자는 피제수(dividend)와 제수(divisor) 두 개이고, 몫(quotient)과 나머지(remainder)가 결과임.<br>
 피제수 = 몫 * 제수 + 나머지이며 나머지는 제수보다 작음.<br>
 
 **나눗셈 알고리즘과 하드웨어**<br>
 
 제수(divisor) 레지스터, ALU, 나머지(remainder) 레지스터는 모두 64비트이고, 몫(quotient) 레지스터만 32비트임.<br>
 32비트 제수는 제수 레지스터의 왼쪽 절반에서 시작해서 반복할 때마다 오른쪽으로 한 비트씩 자리이동함.<br>
 나머지 레지스터는 피제수로 초기화됨.<br>
 제어(control)은 언제 제수와, 몫 레지스터를 자리이동할지, 그리고 언제 나머지 레지스터에 새로운 값을 저장할지 결정함.<br>
 
 **나눗셈 알고리즘의 3단계**<br>
 단계1: 사람과 달리 컴퓨터는 제수가 피제수보다 작다는 것을 먼저 알 만큼 똑똑하지 못 함. 따라서 먼저 단계 1에서 제수를 빼야함.<br>
 단계2: 만약 결과가 양수이면 제수는 피제수와 같거나 더 작음. 따라서 몫에 1을 넣음. 만약 결과가 음수이면 제수를 나머지 레지스터에 다시 더함으로써 원래의 값을 회복하고 몫에는 0을 넣음.<br>
 단계3: 제수는 오른쪽으로 자리이동되고 다시 이 과정을 반복함.<br>
 계산이 완료되면 나머지와 몫은 각각 해당 레지스터에 남게 됨.<br>
 정확한 몫과 나머지를 얻기 위해서는 n+1(n은 비트 수)번의 단계를 거쳐야 함.<br>
 
 **나눗셈 하드웨어의 개선된 버전**<br>
 이 알고리즘과 하드웨어는 훨씬 더 빠르고 싸게 개선될 수 있음.<br>
 뺄셈과 동시에 피연산자와 몫을 자리이동하면 성능 향상이 가능함.<br>
 레지스터와 덧셈기에 사용되지 않는 부분이 있음을 활용하여 덧셈기와 레지스터의 크기를 절반으로 줄일 수 있음.<br>
 제수 레지스터, ALU, 몫 레지스터가 모두 32비트임.<br>
 ALU와 제수 레지스터의 크기가 반으로 줄었고, 나머지가 왼쪽으로 자리이동함.<br>
 몫 레지스터를 나머지 레지스터의 오른쪽 절반에 결합시킴.<br>
 나머지 레지스터는 덧셈기에서 나온는 올림수를 잃지 않기 위해 65비트로 커짐.<br>
 
 **부호있는 나눗셈**<br>
 
 간단한 방법은 제수와 피제수의 부호를 기억하고 이 부호들이 다른 경우에는 몫을 음수화하는 것임.<br>
 나눗셈은 나머지의 부호도 결정해야 하는데 다음 식이 성립해야 함을 기억해야 함.<br>
 피제수 = 몫 * 제수 + 나머지<br>
 +=7 나누기 +=2의 모든 조합을 살펴보자<br>
 7 % 2, 몫 = 3, 나머지 = 1 / 7 = 3 * 2 + 1<br>
 -7 % 2, 몫 = -3, 나머지 = - 1/ -7 = (-3) * 2 - 1<br>
 7 % (-2), 몫 = -3, 나머지 = 1/ 7 = (-2) * (-3) + 1<br>
 (-7) % (-2), 몫 = 3, 나머지 = -1 / -7 = (-2) * 3 - 1<br>
 두 피연산자의 부호가 다를 경우에는 몫의 부호를 음수로 하고, 나머지가 0이 아니면 그 부호는 피제수의 부호를 따르게함.<br>
 
 **더 빠른 나눗셈**<br>
 
 곱셈의 속도를 빠르게 하기 위해 많은 수의 덧셈기를 사용하였지만 같은 방법을 나눗셈에는 적용할 수 없음.<br>
 알고리즘의 다음 단계를 수행하기 전에 뺄셈한 결과의 부호를 알아야 하기 때문임.<br>
 바념ㄴ에 곱셈의 경우 32개의 부분곱을 바로 계산할 수 있음.<br>
 한꺼번에 몫을 두 비트 이상 만들 수 있는 기술이 있음.<br>
 SRT 나눗셈은 매 단계에서 동시에 여러 개의 몫 비트를 예측함.<br>
 피제수와 나머지 상위 비트들을 이용하여 표를 찾아서 몫을 추측하고, 틀린 추측은 그 후의 단계에서 바로잡음.<br>
 오늘날 널리 사용되는 방식은 한 번에 4비트를 추측하는 방법임.<br>
 핵심은 뺄 값을 추측하는 것인데, 이진 나눗셈에는 한 가지 선택밖에 없음.<br>
 이 알고리즘은 각 단계별 추측에 필요한 표를 참조하기 위해 나머지 6비트와 제수의 4비트를 인덱스로 이용함.<br>
 이 빠른 방법의 정확도를 참조표가 얼마나 적합한 값들을 가지고 있는지에 의존함.<br>
 
 **RISC-V에서의 나눗셈**<br>
 
 똑같은 순차 하드웨어가 곱셈과 나눗셈 모두에 이용될 수 있음.<br>
 왼쪽이나 오른쪽으로 자리이동될 수 있는 64비트 레지스터와 덧셈과 뺄셈을 할 수 있는 32비트 ALU만 있으면 됨.<br>
 부호있는 정수와 부호없는 정수를 모두 계싼할 수 있도록 RISC-V에는 나눗셈 명령어 2개 [div(divide)와 divu(divide unsigned)]와 나머지 명령어 2개[rem(remainder)와 remu(remainder unsigned)]가 있음.<br>
 RISC-V는 같은 하드웨어가 곱셈과 나눗셈을 지원하므로, 32비트 레지스터 한 쌍을 두어서 곱셈과 나눗셈 양쪽에 모두 사용하고 있음.<br>
 여러 몫 비트를 동시에 예측하고 예측이 틀렸으면 나중에 바로잡는 방법으로 나눗셈을 빠르게 함.<br>
 RISC-V 나눗셈 명령은 오버플로를 무시하므로, 몫이 너무 커서 오버플로가 발생하는가는 소프트웨어로 검사해야 함.<br>
 나눗셈은 오버플로뿐 아니라 0으로 나누기 같은 부적절한 연산을 초래하기도 함.<br>
 이런 두 가지 비정상 상황을 하드웨어가 찾아주는 컴퓨터들도 있지만, RISC-V는 오버플로나 0으로 나누기를 소프트웨어로 검사해야 함.<br>
 나머지가 음수인 경우 제수를 바로 더해서 원상 복귀하는 대신, 음수 그대로 두고 다음 단계에서 자리이동 된 나머지에 제수를 더하면 더 빠른 알고리즘이 됨.<br>
 이는 (r+d)*2 - d = r*2 +d이기 때문에 가능함.<br>
 이를 비복원 나눗셈 알고리즘이라고 하고, 각 단계마다 1사이클씩 소요됨.<br>
 기존에 알고 있던 알고리즘은 복원 나눗셈 알고리즘이라고 부름.<br>
 뺼셈의 결과가 음수이면 이를 저장하지 않는 세 번째 알고리즘은 조건부 실행 나눗셈 알고리즘이라고 부름.<br>
 이 알고리즘은 평균적으로 1/3만큼 적은 산술 연산을 함.<br>
 
  **:pushpin: 추가**<br>
 
 ALU(산술논리연산장치)는 컴퓨터 내부에서 산술 연산과 논리 연산을 수행하는 하드웨어 장치임.<br>
 이 장치는 CPU의 일부로서, 데이터를 처리하고 연산 결과를 다른 장치나 메모리에 저장하는 등의 작업을 수행함.<br>
 1. 산술연산: 덧셈, 뺼셈, 곱셈, 나눗셈 등의 산술 연산을 수행함.<br>
 2. 논리연산: AND, OR, NOT, XOR 등의 논리 연산을 수행함.<br>
 3. 비트 시프트 연산: 데이터의 비트를 왼쪽이나 오른쪽으로 이동시키는 비트 시프트 연산을 수행함.<br>
 ALU는 연산에 필요한 데이터를 레지스터나 메모리에서 읽어온 후, 연산 결과를 레지스터에 저장함.<br>
 이러한 작업을 통해 ALU는 다양한 연산을 수행하고, CPU가 실행하는 프로그램을 처리하는 데 필요한 연산을 수행함.<br>
 
  **:pushpin: 부동 소수점**
  
  과학적 표기법: 소수점의 왼쪽에는 한 자릿수만이 나타나게 하는 표기법. 0.000000001ten 또는 1.0ten * 10^(-9)(나노초) 등.<br>
  정규화된 수: 과학적 표기법으로 표현된 숫자 중에서 맨 앞에 0이 나오지 않는 것. 1.0ten * 10^(-9)는 정규화된 과학적 표기법이지만, 0.1ten * 10^(-8)은 정규화된 표기법이 아님.<br>
  십진수를 과학적 표기법으로 표시하듯이, 이진수도 과학적 표기법으로 표시할 수 있음.<br>
  이진수를 정규화된 형태로 표현하기 위해서는 소수점 왼쪽에 0이 아닌 숫자가 한 자리만 나타나게 숫자를 자리이동한 후 자리이동 횟수만큼 증가시키거나 감소시킬 수 있는 기수가 필요함.<br>
  이 조건을 만족시킬 수 있는 기수는 2밖에 없음.<br>
  기수가 2인 소수점을 이진 소수점이라고 부름.<br>
  이런 수를 지원하는 컴퓨터 연산을 부동 소수점(floating point) 연산이라고 부름.<br>
  여기서 부동이란 물이나 공기 중에 떠서 움직임을 뜻하는 말임.<br>
  이러한 수에서는 정수에서와 달리 이진 소수점이 고정되어 있지 않음.<br>
  C에서는 이런 수를 나타내기 위해서 float이라는 변수형을 사용함.<br>
  1.xxxxxxtwo * 2^yyyy를 사용함.<br>
  
  **정규화의 장점**<br>
  실수를 정규화된 형태의 표준 과학적 표기법으로 나타내면 3가지 좋은 점이 있음.<br>
  1. 부동 소수점 숫자를 포함한 자료의 교환을 간단하게 함.<br>
  2. 숫자가 항상 이런 형태로 표현된다는 것을 알고 있으므로 부동 소수점 산술 알고리즘이 간단해짐.<br>
  3. 불필요하게 선행되는 0을 소수점 오른쪽에 있는 실제의 숫자로 바꾸기 때문에 한 워드 내에 저장할 수 있는 수의 정밀도를 증가시킴.<br>
  3번은 0.0000123 = 1.23 * 10^(-5)와 같이 표현할 수 있는데, 소수점 이하의 0이나 선행되는 0을 생략하고 유효한 숫자 부분만 표현한다는 얘기임.<br>
 
 **부동 소수점 표현**<br>
 
 소수 부분(fraction)의 크기와 지수(exponent)의 크기 사이에서 타협점을 찾아야 함.<br>
 고정된 워드 크기를 사용하므로 하나를 증가시키면 다른 하나를 감소시켜야 하기 때문임.<br>
 이 문제는 정밀도와 표현 범위 사이의 선택임.<br>
 소수 부분의 크기를 증가시키면 정밀도가 높아지고, 지수의 크기를 증가시키면 표현할 수 있는 수의 범위가 늘어남.<br>
 부동 소수점 수의 크기는 보통 워드 크기의 배수임.<br>
 RISC-V에서 부동 소수점 표현은 32비트로 함.<br>
 s는 부동 소수점 수의 부호(1이면 음수), 지수는 8비트, 소수 부분은 8비트임.<br>
 따라서 (-1)^s * F(fraction) * 2^E(exponent)임.<br>
 오버플로는 지수가 너무 커서 지수 필드에 들어갈 수 없는 경우임.<br>
 언더플로는 음수 지수의 절대값이 너무 커서 표현할 수 없는 경우임.<br>
 언더플로와 오버플로의 발생 가능성을 줄이는 방법으로 지수 부분이 더 큰 다른 표현 형식을 사용할 수 있음.<br>
 C에서는 이것을 double이라고 부름.<br>
 double 연산을 2배의 정밀도(double precision) 부동 소수점 연산이라고 부름.<br>
 float은 단일 정밀도(single precision)임.<br>
 2배 정밀도 부동 소수점 수를 표현하려면 RISC-V 더블워드 1개가 필요함.<br>
 s는 부호 비트, 지수는 11개 비트, 소수는 52개 비트임.<br>
 2.0ten * 10^(-308)부터 2.0ten * 10^308까지의 수를 표현할 수 있음.<br>
 지수의 범위를 크게 해주기도 하지만 더 큰 유효자리를 제공함.<br>
  
  **가수**<br>
  가수(fraction)는 부동 소수점에서 소수점 아래 자릿수를 나타내는 부분임.<br>
  1+f로 구성되어 있고, f는 가수 부분에서 소수점 이하 부분을 나타냄.<br>
  항상 첫 번째 자리가 1로 고정되어 있으므로, 가수 부분에서는 이 1을 생략하고 나머지 비트만 표현함.<br>
  따라서 가수 부분은 항상 1.xxx 형태를 가지며, 첫 번째 자리 1은 생략됨.<br>
  32비트 부동 소수점에서 가장 작은 양수 값을 나타내기 위해 가수 부분에서는 f를 0으로 설정함. 따라서 가수 부분은 1 + 0*2^(-23)로 표현됨.<br>
  이 값은 가수 부분에서 소수점 이하 부분이 모두 0인 경우를 나타냄.<br>
  
  **부동 소수점에서 표현 가능한 가장 작은 값(절대값)**<br>
  exponent = 00000001, 실제 지수 = 1 - 127 = -126<br>
  fraction = 000...00, 실제 가수부 = 1.0<br>
  최소값 = +- 1.0 * 2^(-126), 약 1.2 * 10^(-38)<br>
  exponent 값 00000000과 11111111은 0과 무한을 표현하기 위해 비워둠.<br>
  exponent는 항상 unsigned되도록 하기 위해 bias를 추가해서 비트에 표현함.<br>
  signed bias = 2^8 - 1 = 127임.<br>
  
  **부동 소수점에서 표현 가능한 가장 큰 값(절대값)**<br>
  exponent = 11111110, 실제 지수 = 254 - 127 = 127<br>
  fraction = 111...11, 실제 가수부 = 2.0<br>
  최댓값 = += 2.0 * 2^127, 약 3.4 * 10^38<br>
  
  **예외와 인터럽트**<br>
  오버플로나 언더플로가 발생했을 때 문제가 생겼다는 것을 사용자에게 알려주기 위해서 예외(exception)를 발생시킴. 예외를 인터럽트(interrupt)라고도 부름.<br>
  예외나 인터럽트는 본질적으로 예정되지 않은 프로시저 호출임.<br>
  오버플로가 발생한 명령어의 주소는 레지스터에 저장되고 컴퓨터에 그 예외에 해당하는 적합한 루틴을 호출하기 위해 미리 정해진 주소로 점프함.<br>
  이 주소에 있는 문제 해결 코드를 실행한 후에 프로그램 실행이 계속되는 경우도 있기 때문에 인터럽트가 발생한 주소를 저장하는 것임.<br>
  RISC-V는 오버플로와 언더플로가 발생해도 예외를 발생시키지 않음.<br>
  대신 소프트웨어가 fcsr(floating point control and status register)를 읽어서 오버플로나 언더플로가 발생했는지 검사할 수 있음.<br>
  
  **IEEE 754 부동 소수점 표준**<br>
  
  1980년대 이후에 만들어진 컴퓨터는 거의 모두 이 표준을 사용하고 있음.<br>
  이 표준은 부동 소수점 프로그램의 이식을 매우 쉽게 하였고, 컴퓨터 연산의 질을 크게 향상시킴.<br>
  유효자리 부분에 더 많은 수를 담기 위해 정규화된 이진수의 가장 앞쪽 1비트를 생략하고 표현하지 않음.<br>
  따라서 실질적인 유효자리의 길이는 단일 정밀도 표현이 24비트(숨겨진 1과 23비트 소수 부분), 2배 정밀도는 53비트(1 + 52비트)임.<br>
  표현에 정확을 기하기 위해서 유효자리(significand)라는 용어는 숨겨진 1을 포함하는 24 또는 53비트를 나타내는 데 사용하고, 23 또는 52비트를 나타낼 때는 소수 부분이라는 용어를 사용함.<br>
  숫자 0.0은 선행하는 1이 없기 때문에, 이를 구별하기 위해서 예약된 지수값 0을 사용하며 이 경우 하드웨어는 소수 부분 앞에 1을 붙이지 않음.<br>
  따라서 00...00two는 0을 나타냄.<br>
  0을 제외한 나머지 수는 (-1)^s * (1+소수 부분) * 2^E로 설명됨.<br>
  IEEE 754는 비정상적인 사건을 표현하는 특수 심벌이 있음.<br>
  0으로 나누기에 대해 인터럽트를 거는 대신에 소프트웨어가 +∞나 -∞을 표시하는 비트열을 결과값으로 정할 수 있음.<br>
  
  <pre>
  sigle precision exponent가 0일 때 fraction이 0이면 0이고, fraction이 nonzero면 +=denormalized number임.
  double precision에서도 마찬가지임.
  
  sigle precision에서 exponent가 1-254일 때 fraction이 어떤 것이 오든 결과는 += floating point number임.
  double precision은 exponent의 범위가 1-2046임.
  
  single precision에서 exponent가 255이고 fraction이 0일 때 결과는 +-infinity임.
  double precision은 exponent가 2047임.
  
  sigle precision에서 exponent가 255인데, fraction이 0이 아닐 때는 결과가 NaN(Not a Number)임.
  double precision은 exponent가 2047임.
  </pre>
  
  IEEE 754 설계자들은 정수 비교로 쉽게 정렬할 수 있는 부동 소수점 표현을 원했음.<br>
  이런 이유로 less than, greater than, equal to 0 테스트를 빠르게 할 수 있도록 부호 비트가 최상위 비트에 놓이게 됨.<br>
  지수를 유효자리 앞에 두면 부호가 같은 수를 비교할 때 지수가 큰 수가 지수가 작은 수보다 더 큰 정수처럼 보임.<br>
  이것 또한 부동 소수점 수를 정수 비교 명령어로 정렬하는 일을 쉽게 해줌.<br>
  하지만 음수 지수는 숫자 정렬을 어렵게 만듬.<br>
  음수 지수를 나타내기 위해 2의 보수법이나 지수의 최상위 비트를 1로 만드는 표현법을 사용하면, 지수가 음수일 때 매우 큰 수처럼 보임.<br>
  예를 들어 1.0two * 2^(-1)은 0 11111111 00000000000000000000000로 커보일 것임.<br>
  반면 1.0two * 2^1은 0 00000001 00000000000000000000000로 작아보임.<br>
  이상적인 표기법은 가장 음수인 지수를 00...00two로, 가장 양수인 지수를 11...11two로 표현하는 것임.<br>
  이와 같은 방식을 바이어스된 표현 방식(biased notation)이라고 부름.<br>
  단일 정밀도 표현방식에서는 127을 사용함.<br>
  -1은 0111 1110two = 126ten임.<br>
  +1은 1000 0000two = 128ten임.<br>
  2배 정밀도를 위한 지수의 바이어스는 1023임.<br>
  단일 정밀도에서 표현할 수 있는 가장 작은 수는 +- 1.0000 0000 0000 0000 0000 000two * 2^(-126)임.<br>
  가장 큰 수는 +1.1111 1111 1111 1111 1111 111two * 2^126임.<br>
 
 <pre>
 -0.75ten을 IEEE 754 이진 표현법에 따라 단일 정밀도 및 2배 정밀도 표현방식으로 나타내라.
 
 -0.11two = -1.1two * 2^(-1) = 1 0111 1110 100...00(단일 정밀도)<br>
 -1.1two * 2^(-1) = 1 0111 1111 110 100...00(단일 정밀도)<br>
 </pre>

 <pre>
 아래의 단일 정밀도 부동 소수점 수가 나타내는 값을 십진수로 표시하라
 1 1000 0001 0100 00..00
 
 부호: -
 지수: 129 - 127 = 2
 1+소수: 1 + 0.25 = 1.01two
 
 -1.01two * 2^2 = -101two = -5
 </pre>
 
 2008년에 IEEE 754를 개정하였는데, 16비트 형식(반정밀도)과 128비트 형식(4배 정밀도)를 추가하였음.<br>
 반정밀도 형식은 1비트 부호, 5비트 지수(바이어스 15), 10비트 소수로 표현됨.<br>
 4배 정밀도 형식은 1비트 부호, 15비트 지수(바이어스 262143), 112비트 소수로 표현됨.<br>
 
 **부동 소수점 덧셈**<br>
 
 9.999ten * 10^1과 1.610ten * 10^(-1)을 더해보기.<br>
 단계1: 작은 지수를 갖는 수의 소수점을 큰수에 맞춰 정렬함.<br>
 9.999ten * 10^1과 0.01610ten * 10^1로 정렬함.<br>
 그러나 4자리의 십진수만을 표시할 수 있기 때문에 0.0161ten * 10^1임.<br>
 <br>
 단계2: 유효자리를 서로 더함.<br>
 9.999ten + 0.016ten = 10.015ten<br>
 따라서 10.015ten * 10^1이 됨.<br>
 <br>
 단계3: 정규화된 과학적 표기법에 따라 정돈함.<br>
 1.0015ten * 10^2이 됨.<br>
 이 때, 지수에서 오버플로나 언더플로가 일어나는지 확인해야 함.<br>
 <br>
 단계4: 유효자리가 4자리라고 가정했으니 정돈함.<br>
 1.0015ten * 10^2 에서 1.002ten * 10^2로 바뀜.<br>
 
 **이진 소수점 덧셈**<br>
 
 단계1~4는 모두 같으나 지수 비트가 모두 0이거나 1인 패턴은 이미 예약되어 있다는 것에 주의하자.<br>
 <pre>
 0.5ten과 -0.4375ten의 이진 덧셈을 수행하라. 4비트의 정밀도를 사용함.
 
 0.5ten = 0.1two * 2^0 = 1.0two * 2^(-1)
 -0.4375ten = -7/16ten = -0.0111 * 2^0 = -1.11 * 2^(-2)
 
 단계1: 1.0two * 2^(-1)와 -0.111two * 2^(-1)로 정렬됨.
 단계2: 0.001two * 2^(-1)
 단계3: 1.000two * 2^(-4), -126 <= -4 <= 127이므로 오버플로나 언더플로 일어나지 않음.
 단계4: 1.000two * 2^(-4) = 0.0001two = 1/2^4ten = 1/16 = 0.0625ten
 </pre>
 
 **부동 소수점 곱셈**<br>
 
 
 1.110ten * 10^10 * 9.200ten * 10^(-5), 유효자리에는 4자리, 지수에는 2자리까지 저장할 수 있다고 가정함.<br>
 단계1: 피연산자들의 지수를 더하기만 하면 곱의 지수를 확인할 수 있음.<br>
 새로운 지수 = 10 + (-5) = 5<br>
 bias를 고려하면 ((10 + 127) - 127) + ((-5 + 127) - 127) = 5<br>
 <br>
 단계2: 유효자리의 곱셈.<br>
 1.110ten * 9.200ten = 10.212000ten<br>
 소수점 오른쪽에 세 자리수가 있고, 그 수를 곱했으니 오른쪽으로부터 여섯 번째 자리에 소수점을 찍음.<br>
 <br>
 단계3: 정규화<br>
 10.212000ten * 10^5 = 1.0212000ten * 10^6 = 1.0212ten * 10^6
 <br>
 단계4: roudning<br>
 1.0212ten * 10^6 = 1.021ten * 10^6
 <br>
 단계5: 결과의 부호는 피연산자의 부호에 따라 결정됨. 부호가 같으면 양수, 다르면 음수.<br>
 +1.021ten * 10^6
 <br>
 이진수 부동 소수점 수의 곱셈도 십진수 부동 소수점 수의 곱셈과 매우 유사함.<br>
 
 **이진 부동 소수점 수의 곱셈**<br>
 
 0.5ten과 -0.4375ten을 곱하라. 유효자리에는 4자리까지 저장할 수 있음.
 <pre>
 0.5ten = 0.100two * 2^0 = 1.000two * 2^(-1)
 -0.4375ten = -7/16ten = -0.0111two * 2^0 = -1.110two * 2^(-2)
 
 단계1: 새로운 지수는 -1 + (-2) = -3임.
 단계2: 1.000two * 1.110two = 1.110000two. 1.110two * 2^(-3)임.
 단계3: 이미 정규화 되어 있고, -126 <= -3 <= 127임. 따라서 오버플로나 언더플로 발생하지 않음.
 단계4: rounding 필요없음.
 단계5: 부호가 서로 다르므로 -임. -1.110two * 2^(-3)임.
 
 -1.110two * 2^(-3) = -0.001110two = -0.00111two = -7/32ten = -0.21875ten
 </pre>
 
 **RISC-V의 부동 소수점 명령어**<br>
 
 RISC-V는 f0~f31이라고 불리는 부동 소수점 레지스터를 별도로 둠.<br>
 단일 정밀도 레지스터가 따로 있는 것은 아니고 2배 정밀도 레지스터의 아래쪽 절반을 사용함.<br>
 부동 소수점 레지스터 f0은 정수 레지스터 x0와 달리 항상 상수 0으로 고정되어 있지 않음.<br>
 2^30의 memory words가 있음. memory[0], memory[4], ..., momory[4,294,967,292]. <br>
 메모리는 데이터 전송 명령어에 의해 access됨.<br>
 RISC-V는 byte address를 이용하므로 메모리 간에 4만큼 차이가 남.<br>
 memory는 data structure, array, spilled register를 저장함.<br>
 <br>
 
 RISC-V의 floating point 어셈블리어는 다음과 같음.
 <pre>
 Arithmetic
 FP add single: fadd.s f0, f1, f2 / f0 = f1 + f2
 FP subtract single: fsub.s f0, f1, f2 / f0 = f1 - f2
 FP multiply single: fmul.s f0, f1, f2 / f0 = f1 * f2
 FP divide single: fdiv.s f0, f1, f2 / f0 = f1 /f2
 FP sqaure root single: fsqrt.s f0, f1 / f0 = f1^(1/2)
 double은 .s 대신 .d를 넣음.
 
 Comparison
 FP equality single: feq.s x5, f0, f1 / x5 = 1 if f0 == f1, else 0
 FP less than single: flt.s x5, f0, f1 / x5 = 1 if f0 < f1, else 0
 FP less than or equals single: fle.s x5, f0, f1 / x5 = 1 if f0 <= f1, else 0
 double은 .s대신 .d를 넣음.
 
 Data transfer
 FP load word: flw f0, 4(x5) / f0 = momory[x5 + 4]
 FP load doubleword: fld f0, 8(x5) / f0 = memory[x5 + 8]
 FP store word: fsw f0, 4(x5) / memory[x5 + 4] = f0
 FP store doubleword: fsd f0, 8(x5) / memory[x5 + 8] = f0
 </pre>
 
 비교 명령어 feq, flt, fle는 비교가 거짓일 때 정수 레지스터를 0으로 만들고 참일 때 1로 만듬.<br>
 소프트웨어는 정수 분기 명령어 beq와 bne를 사용하여 부동 소수점 비교 결과에 따라 분기할 수 있음.<br>
 메모리에서 단일 정밀도 수 2개를 읽어 와서 더한 다음에 합을 다시 메모리에 저장하는 RISC-V 코드는 다음과 같음.<br>
 <pre>
 flw f0, 0(x10)
 flw f1, 4(x10)
 fadd.s f2, f0, f1
 fsw f2, 8(x10)
 </pre>
 
 부동 소수점 명령어는 이에 대응하는 정수 명령어와 같은 형식을 사용함.<br>
 예를 들어 적재는 I타입, 저장은 S타입, 산술 명령어는 R타입 형식을 사용함.<br>
 
 프로그램이 정수 연산을 할 때와 부동 소수점 연산을 할 때는 보통 다른 데이터를 사용하므로, 레지스터를 분리함.<br>
 이럴 경우 프로그램 수행에 필요한 명령어의 수가 약간 증가할 뿐임.<br>
 정작 크게 영향을 받는 부분은 부동 소수점 레지스터와 메모리 사이에 데이터 이동에 사용할 별도의 데이터 전송 명령어들을 만들어야 한다는 것임.<br>
 별도의 부동 소수점 레지스터를 사용하는 것의 장점은 다음과 같음.<br>
 </pre>
 1. 명령어 형식의 비트 수를 늘리지 않고도 2배나 많은 레지스터를 사용할 수 있음.
 2. 정수 레지스터와 부동 소수점 레지스터가 따로 있으니 레지스터 대역폭이 2배로 늘어남.
 3. 부동 소수점에 맞게 레지스터를 특화시킬 수 있음. 예를 들어 어떤 컴퓨터는 레지스터에 있는 다양한 크기의 피연산자들을 한 가지 내부 형식으로 변환함.
 </pre>
 
 일반적으로, 컴퓨터 아키텍처에서는 명령어의 형식을 정해 놓고 그에 맞게 비트 수를 할당함.<br>
 예를 들어, 32비트 아키텍처에서는 명령어 하나당 32비트의 메모리 공간을 사용함.<br>
 부동 소수점 레지스터를 추가할 때도 부동 소수점 명령어를 위한 별도의 비트 수를 할당하지 않고도, 부동 소수점 명령어를 처리할 수 있음.<br>
 
 프로그래머들이 사용하는 소스 코드에서는 부동 소수점 숫자가 다양한 크기와 형식으로 표현될 수 있음.<br>
 이 때문에, 컴퓨터는 레지스터에 저장된 부동 소수점 피연산자들을 한 가지 내부 형식으로 변환하여 처리함.<br>
 이 내부 형식은 부동 소수점 명령어에 맞게 설계되어 있어, 부동 소수점 연산을 더 효율적으로 처리할 수 있도록 함.<br>
 
 **추가**<br>
 분기(branch)는 프로그램의 제어 흐름을 변경하여, 다른 위치로 이동하는 것을 말함.<br>
 분기는 조건부 분기와 비조건부 분기로 나눌 수 있음.<br>
 조건부 분기는 주어진 조건에 따라 분기하는 것으로, "만약 A가 B보다 크면 위치 X로 분기하고, 그렇지 않으면 위치 Y로 분기한다"와 같은 조건이 있을 때, A와 B를 비교하여 조건에 따라 분기함.<br>
 비조건부 분기는 어떠한 조건에도 관계없이 주어진 위치로 분기하는 것으로, "주어진 위치로 분기한다"와 같은 형태임.<br>
 Jump는 비조건부 분기를 의미함.<br>
 정수 분기는 주어진 조건에 따라 프로그램 카운터가 다른 주소로 분기하는 것을 말함. 이 때, 비교 대상이 되는 값이 정수일 경우 이를 정수 분기라고 함.<br>
 beq와 bne는 분기 명령어임.<br>
 beq는 Branch If Equal이고 bne는 Branch if Not Equal임.<br>
 이 두 분기 명령어는 주어진 두 개의 레지스터 값이 같거나 다를 경우, 프로그램 카운터를 주어진 주소로 변경하여 분기함.<br>
 
 **부동 소수점 C 프로그램을 RISC-V 어셈블리 코드로 컴파일**<br>
 
 <pre>
 float f2c (float fahr)
 {
  return ( (5.0/9.0) * (fahr - 32.0) );
 }
 </pre>
 
 부동 소수점 인수 fahr은 f10에 넣어서 전달하고 결과 또한 f10에 저장한다고 가정하자. RISC-V 어셈블리 코드를 작성하라.<br>
 
 <pre>
 f2c:
  flw f0, const5(x3) // f0 = 5.0
  flw f1, const9(x3) // f1 = 9.0
 </pre>
 컴파일러가 레지스터 x3로 쉽게 접근할 수 있는 거리에 부동 소수점 상수 3개(5.0, 9.0, 32.0)를 넣는다고 가정함.<br>
 const5(x3)은 x3+20위치의 4바이트 값을 참조하라는 뜻임.<br>
 
 <pre>
 fdiv.s f0, f0, f1 // f0 = 5.0 / 9.0
 </pre>
 
 5.0/9.0 값을 얻기 위해 이 둘을 나눔.<br>
 
 <pre>
 flw f1, const32(x3) // f1 = 32.0
 fsub.s f10, f10, f1 // f10 = fahr - 32.0
 fmul.s f10, f0, f10 // f10 = (5.0/9.0) * (fahr - 32.0)
 jalr x0, 0(x1) // return
 </pre>

x0 레지스터는 RISC-V에서 항상 0으로 설정되는 레지스터임.<br>
jalr(jump and link register) 명령어에서 목적지 레지스터를 꼭 지정해야 하기 때문에, 반환값이 없는 함수 호출시 목적지 레지스터로 x0을 사용하는 것이 관례임.<br>
이 경우 f10에 float을 저장하지만 return은 아무것도 하지 않는다고 볼 수 있음.<br>
0(x1)은 x1 레지스터에 저장된 주소에서 0바이트 떨어진(offset) 곳의 주소를 나타냄.<br>
이로 인해 함수를 호출한 지점으로 돌아가게 됨.<br>

**2차원 배열을 사용하는 부동 소수점 C 프로시저를 RISC-V 어셈블리 코드로 컴파일**<br>

대부분의 부동 소수점 계산은 2배 정밀도 연산을 사용함.<br>
행렬 곱셈 C = C + A*B를 계산하겠음.<br>

<pre>
void mm (double c[][], double a[][], double b[][])
{
 size_t i, j, k;
 for (i = 0; i < 32; i = i + 1)
  for (j = 0; j < 32; j = j + 1)
   for (k = 0; k < 32; k = k + 1)
    c[i][j] = c[i][j] + a[i][k] * b[k][j];
}
</pre>

배열의 시작 주소는 매개변수이므로 x10(c), x11(a), x12(b)에 있고, 정수 변수는 x5(i), x6(j), x7(k)에 있다고 가정함.<br>
이 프로시저 본체에 대한 RISC-V 어셈블리 코드는 무엇인가?
<br>
c[i][j]는 가장 안쪽 순환문에 사용됨.<br>
이 순환문의 인덱스는 k이므로 c[i][j]에 영향을 미치지 않음.<br>
따라서 순환문을 반복할 때마다 c[i][j]를 적재하고 저장할 필요는 없음.<br>
대신 컴파일러는 순환문 외부에서 c[i][j]를 레지스터에 적재하고, 같은 레지스터에 a[i][k] * b[k][j]의 합을 축적시킴.<br>
가장 안쪽 순환문이 끝나면 그 합을 c[i][j]에 저장함.<br>
<pre>
  mm:...
    addi x28, x0, 32 // x28 = 32(row의 사이즈, loop의 끝)
    addi x5, x0, 0 // i = 0;
L1: addi x6, x0, 0 // j = 0;
L2: addi x7, x0, 0 // k = 0; 
</pre>

32 * 32 2차원 배열은 32개의 원소를 갖는 1차원 배열 32개와 똑같음.<br>
따라서 i개의 1차원 배열을 건너뛰고 열을 찾아야함.<br>

<pre>
slli x30, x5, 5 // x30 = i * 2^5 (size of row of c)
add x30, x30, x6 / x30 = i & size (row) + j
</pre>

이 합을 바이트 인덱스로 바꾸기 위해 행렬 원소의 크기를 곱함.<br>
2배 정밀도 원소 하나는 8바이트씩 차지하므로 8을 곱해야 함.

<pre>
slli x30, x30, 3 // x30 = byte of offset of [i][j]
</pre>

이 합을 c의 시작 주소에 더하여 c[i][j]의 주소를 구하거, 2배 정밀도 수 c[i][j]를 f0에 적재함.<br>

<pre>
add x30, x10, x30 // x30 = byte address of c[i][j]
fld f0, 0(x30) // f0 = 8 bytes of c[i][j]
</pre>

주소를 계산하고 2배 정밀도 수 b[k][j]를 레지스터에 넣은 다음 5개 명령어는 앞의 5개 명령어와 실제적으로 같음.<br>

<pre>
L3: slli x29, x7, 5 // x29 = k * 2^5 (size of row of b)
    add x29, x29, x6 // x29 = k * size(row) + j
    slli x29, x29, 3 // x29 = byte offset of [k][j]
    add x29, x12, x29 // x29 = byte address of b[k][j]
    fld f1, 0(x29) // f1 = 8 bytes of b[k][j] 
</pre>

다음 5개 명령어도 앞의 5개 명령어와 하는 일은 같음. 주소를 계산하고 2배 정밀도 수인 a[i][k]를 적재함.<br>

<pre>
slli x29, x5, 5 // x29 = i * 2^5 (size of row of a)
add x29, x29, x7 // x29 = i * size(row) + k
slli x29, x29, 3 // x29 = byte offset of [i][k]
add x29, x11, x29 // x29 = byte address of a[i][k]
fld f2, 0(x29) // f2 = a[i][k]
</pre>

이제 모든 데이터를 적재하였으므로 부동 소수점 연산을 할 수 있음.<br>
레지스터 f2와 f1에 있는 a와 b의 원소를 곱하고 합을 f0에 축적함.<br>

<pre>
fmul.d f1, f2, f1 // f1 = a[i][k] * b[k][j]
fadd.d f0, f0, f1 // f0 = c[i][j] + a[i][k] * b[k][j]
</pre>

k를 증가시키고 인덱스가 32가 아니면 순환문의 처음으로 다시 돌아감.<br>
만약 32이면 가장 안쪽의 순환문이 끝나는 것이므로 f0에 축적된 합을 c[i][j]에 저장함.<br>

<pre>
addi x7, x7, 1 // k = k + 1
bltu x7, x28, L3 // if (k < 32) go to L3
fsd f0, 0(x30) // c[i][j] = f0
</pre>

bltu는 Branch If Less Than, Unsigned임.<br>
첫 번째 레지스터의 값이 두 번째 레지스터의 값보다 작은 경우 지정된 분기 대상 주소로 분기함.<br>
u가 붙은 이유는 부호 없는 두 개의 값을 비교하기 때문에 붙음.<br>
u가 붙지 않은 blt는 부호 있는 값을 비교하는 명령어임.<br>

<pre>
addi x6, x6, 1 // j = j + 1
bltu x6, x28, L2 // if (j < 32) go to L2
addi x5, x5, 1 // i = i + 1
bltu x5, x28, L1 // if (i < 32) go to L1
</pre>

중간과 가장 바깥쪽 순환의 인덱스 변수를 증가시킴.<br>
인덱스가 32가 아니면 순환문으로 되돌아가고, 32면 빠져나옴.<br>

**추가**<br>

<pre>
addi x1, x0, 10 // x1 = 0 + 10
add x2, x1, x0 // x2 = x1 + 0
</pre>

addi x1, x0, 10은 x0에 10을 더한 값을 x1에 저장함.<br>
이 때, addi 명령어라서 상수 10을 직접 인코딩해서 사용함.<br>
add x2, x1, x0은 x1과 x0의 값을 더하여 x2에 저장함.<br>
레지스터에 저장된 값을 사용하기 때문에 직접 인코딩하지 않고 레지스터 값을 가져와서 사용함.<br>
즉, addi 명령어는 상수를 사용하여 연산을 수행하고, add 명령어는 레지스터 값을 사용하여 연산을 수행함.<br>

<pre>
addi x7, x7, 1        // k++
blt x7, x28, L2       // if (k < 32) goto L2
addi x6, x6, 1        // j++
blt x6, x28, L1       // if (j < 32) goto L1
addi x5, x5, 1        // i++
blt x5, x28, L1       // if (i < 32) goto L1
jr x1                 // return
</pre>

for문은 3개인데 loop는 2개일 수 있는 이유는 위와 같음.<br>

**고난도1**<br>

C를 비롯한 많은 프로그래밍 언어가 행 우선순위(row major order)로 배열을 저장함.<br>
Fortran은 배열이 한 열씩 순서대로 저장되는 열 우선순위(column major order)를 사용함.<br>

**고난도2**<br>
정수 레지스터와 부동 소수점 레지스터를 따로 두는 이유 중 하나는 1980년대 마이크로프로세서가 한 칩에 부동 소수점 유닛과 정수 유닛을 함께 넣을 수 있을 만큼 트랜지스터가 많지 않았던 것도 있었음.<br>
따라서 부동 소수점 레지스터를 포함하는 부동 소수점 유닛은 독립적인 2차 칩 형태의 선택 사양이었음.<br>
이러한 선택 사양의 가속 칩을 코프로세서 칩이라고 부름.<br>
1990년대 초 이후에는 마이크로프로세서와 같은 칩에 부동 소수점 유닛이 집적됨.<br>

**고난도3**<br>
나눗셈 시간을 단축하는 방법 중 하나는 곱셈기의 속도가 빨라진 것을 이용하는 것임.<br>
Newton의 반복법은 함수가 0이 되는 값을 찾는 것인데, 이를 이용하여 (1/제수)를 계산한 후 이 값을 피제수와 곱하는 것임.<br>
반복법은 여분의 비트를 많이 계산하지 않고는 적절한 자리맞춤을 할 수 없다는 단점이 있음.<br>
<pre>
5(피제수)을 3(제수)으로 나누는 경우. 이 때, 제수의 역수를 구하면 1/3임. 이 역수를 이용하여 5/3을 계산할 수 있음.

Newton의 반복법을 이용하여 1/3을 구해봄.
1. f(x) = 5/x -3을 정의함. f'(x) = -5/x^2임.
2. 초기 추측값 x0 = 2를 선택함.
3. x1 = x0 - f(x0) / f'(x0) = 2 - (2.5 - 3) / 7 = 2 - 2/5 = 1.6
   x2 = x1 - f(x1) / f'(x1) = ....
4. x의 값은 점점 정확해지고 이 결과에 피제수인 5를 곱하면 5를 3으로 나눈 값을 구할 수 있음.
</pre>

따라서 곱셈기를 이용하여 나눗셈의 시간을 단축시킬 수 있음.

**고난도4**<br>

Java는 Java 부동 소수점 데이터형과 연산의 정의에 IEEE 754 용어를 그대로 받아들임.<br>
화씨를 섭씨로 바꾸는 프로그램은 그대로 클래스 메소드로 쓰일 수 있음.<br>
그러나 다차원 배열을 사용하는 프로그램은 Java에서 바로 지원되지는 않음.<br>
Java는 배열의 배열을 허용함. 그러나 각 배열은 C의 다차원 배열과는 달리 길이가 각각 다를 수 있음.<br>
두 번째 예제의 Java 버전을 만든다면 배열의 경계를 검사하는 코드가 상당히 많이 들어가야 함.<br>
한 행의 접근이 끝나면 새로운 길이를 계산하는 코드도 포함되어야 함.<br>
객체 참조가 널(null)이 아닌 것도 확인해야 함.<br>

**정확한 산술**<br>
가장 작은 수와 가장 큰 수 사이의 모든 수를 정확하게 나타낼 수 있는 정수와는 달리, 부동 소수점 숫자는 실제로 나타낼 수 없는 수의 근사값인 것이 보통임.<br>
최선의 방법은 실제의 수에 가장 근접한 부동 소수점 표현을 구하는 것임.<br>
정확하게 자리맞춤하기 위해서는 계산할 때 하드웨어가 추가 비트를 포함해야 함.<br>
만약 중간 결과가 원래 데이터 비트 수만큼만 보존되고 나머지는 다 잘려나간다면 자리맞춤할 기회는 오지 않을 것임.<br>
IEEE 754는 계산하는 동안 오른편에 항상 2개의 추가 비트를 유지함.<br>
이를 각각 보호 비트(guard bit, 첫 번째)와 자리맞춤 비트(round bit, 두 번째)라고 부름.<br>

**보호 자리 수를 사용한 자리맞춤**<br>
<pre>
유효자리가 십진수 세 자리라고 가정하고 2.34ten * 10^2에 2.56ten * 10^0을 더하라.
유효자리 숫자 세 자리를 사용하여 가장 가까운 십진수로 자리맞춤하라.
처음엔 보호 자리와 자리맞춤 자리를 사용하여 계산하고, 다음에는 이를 사용하지 말고 계산하라.
</pre>

2.56ten * 10^0은 0.0256ten * 10^(2)로 이동함.<br>
보호 자리 및 자리맞춤 자리가 존재하기 때문에 자를 필요 없음.<br>
2.3400ten + 0.0256ten = 2.3656ten이므로 결과는 2.3656ten * 10^2이 됨.<br>
자리맞춤할 두 자리를 갖고 있기 때문에 0부터 49는 버리고, 51부터 99는 올림.<br>
50은 타이브레이커이므로 50%는 버리고 50%는 올림.<br>
세 자리 유효숫자로 자리맞춤하면 결과는 2.37ten * 10^2이 됨.<br>
보호 자리와 자리맞춤 자리가 없으면 두 자리를 버리고 덧셈을 해야 함.<br>
따라서 2.34ten + 0.02ten = 2.36ten이므로 2.36ten * 10^2이 됨.<br>
<br>
자리맞춤 시 최악의 경우는 실제 값이 두 부동 소수점 표현의 중간이 되는 경우임.<br>
부동 소수점에서 정확도는 유효자리의 최하위 비트 중 오류가 발생한 것이 몇 비트인가에 따라 결정됨.<br>
이 척도를 ulp(units in the last place)라고 함.<br>
어떤 수의 최하위 유효자리 비트 중 2개에 오류가 있을 때 ulp가 2임.<br>
오버플로, 언더플로 또는 유효하지 않은 연산의 예외가 없는 한, IEEE 754는 컴퓨터가 1/2 ulp 이내의 수를 사용함을 보장함.<br>

**고난도**<br>

덧셈 예제에서 실제로는 추가 자릿수가 하나만 있어도 되었지만, 곱셈할 때는 2개 다 필요함.<br>
이진 곱셈 결과는 맨 앞에 0이 하나 있을 수 있음.<br>
이 때 정규화 과정에서 곱을 한 비트 왼쪽으로 자리이동 해야 함.<br>
이 자리이동 시에 보호 비트가 곱의 최하위 비트로 들어가고, 자리맞춤 비트는 곱을 정확히 자리맞춤할 수 있게 도와줌.<br>
IEEE 754에는 4가지 자리맞춤 모드가 있음.<br>
항상 자리올림(+무한대 방향), 항상 자리내림(-무한대 방향), 잘라내기(truncate), 그리고 가장 가까운 짝수로의 자리맞춤(round to nearest even)임.<br>
미국 국세청은 항상 0.5달러를 자리올림해서 이익이 더 돌아감. 더 공평한 방법은 절반은 자리올림하고, 절반은 자리내림 하는 것임.<br>
IEEE 754 표준은 계산된 결과값이 두 값의 가운데에 위치할 때, 최하위 비트가 홀수면 더하기 1을 하고, 짝수면 잘라내라고 규정함.<br>
이 방법은 항상 최하위 비트를 0으로 만들어 줌.<br>
이 방식이 가장 가까운 짝수로의 자리 맞춤임.<br>
이 방식이 가장 널리 사용되며 Java는 이 방식만 지원함.<br>
자리맞춤  비트들을 추가로 사용하는 목적은 무한한 정밀도로 중간 계산 결과를 구한 후 자리맞춤한 것과 같은 최종 결과를 갖게 하기 위해서임.<br>
이 목적을 달성하고 가장 가까운 짝수로의 자리맞춤을 하기 위해서는 보호 비트와 자리맞춤 비트 외에 세 번째 비트가 필요함.<br>
이 비트는 자리맞춤 비트 오른쪽에 0이 아닌 비트들이 하나라도 존재하면 1이 됨.<br>
이 비트는 점착 비트(sticky bit)라고 불리며, 자리맞춤시 0.50..00ten과 0.50..01ten을 구별할 수 있게 해줌.<br>
점착 비트는 덧셈할 때 지수를 같게 만들기 위해서 더 작은 수를 오른쪽으로 자리이동하면서 1이 될 수 있음.<br>
5.01ten * 10^(-1)에 2.34ten * 10^2을 더한다고 가정함.<br>
보호비트와 자리맞춤 비트를 사용하는 경우에도 실제로 0.0050에 2.34를 더하므로 2.3450이 됨.<br>
오른쪽에 0이 아닌 비트가 있었기 때문에 점착 비트는 1이 됨.<br>
점착 비트 없이는 결곽밧이 2.345000..00이 되어 가장 가까운 짝수로 자리맞춤하면 2.34가 됨.<br>
점착 비트를 사용하면 2.345000..00보다는 크다는 것을 알 수 있으므로 2.35가 됨.<br>

**고난도**<br>
RISC-V, MIPS-64, PowerPC, AMD SSE5, Intel AVX 구조는 다 3개의 레지스터에 a = a + (b *c) 연산을 하는 곱셈 후 덧셈(multiply and add) 명령어를 가지고 있음.<br>
이 연산이 자주 사용되는 경우 이 명령어를 사용하여 부동 소수점 성능을 높일 수 있음.<br>
별도의 명령어로 곱하고 더하면 자리맞춤을 두 번 해야 하는데, 이 명령어는 덧셈 뒤에 한 번만 자리맞춤을 수행함.<br>
자리맞춤을 한 번만 하면 정밀도가 높아짐.<br>
이와 같이 자리맞춤을 한 번만 하는 연산을 곱셈-덧셈 융합(fused multiply add)이라 부르며, IEEE 754-2008 표준에 추가됨.<br>

<pre>
int(C) int(Java) / data transfers: lw, sw / operations: add, sub, addi, mul, mulh, mulhu, mulhsu, div, divu, rem, remu, and, andi, or, ori, xor, xori
unsigned int(C) -(Java) / data transfers: lw, sw / operations: add, sub, addi, mul, mulh, mulhu, mulhsu, div, divu, rem, remu, and, andi, or, ori, xor, xori
char(C) -(Java) / data transfers: lb, sb / operations: add, sub, addi, mul, div, divu, rem, remu, and, andi, or, ori, xor, xori
short(C) char(Java) / data transfers: lh, sh / operations: add, sub, addi, mul, div, divu, rem, remu, and, andi, or, ori, xor, xori
float(C) float(Java) / data transfers: flw, fsw / operations: fadd.s, fsub.s, fmul.s, fdiv.s, feq.s, flt.s, fle.s
double(C) double(Java) / data transfers: fld, fsd / operations: fadd.d, fsub.d, fmul.d, fdiv.d, feq.d, flt.d, fle.d
</pre>

**고난도**<br>

NaN을 포함하는 비교를 수용하기 위해서 IEEE 754 표준은 순서화(ordered)와 비순서화(unordered) 선택안을 포함시킴.<br>
RISC-V에는 비순서화 명령어가 없지만, 순서와 비교 명령어 몇 개를 잘 사용하면 같은 효과를 얻을 수 있음.(Java는 비순서화 비교를 지원하지 않음.)<br>
0과 가장 작은 정규화 수 사이에 존재하는 수를 표현하기 위해  비정규화된 형태의 숫자들을 허용함.<br>
이들은 모두 지수가 0이지만, 유효자리는 0이 아님.<br>
이 방식은 숫자가 작아지면서 유효자리가 점점 줄어들어서 궁극적으로는 0이 되는 것을 허용함. 이를 점진적 언더플로라고 함.<br>
정규화된 양수 단일 정밀도 수 중에서 가장 작은 것은 1.0000 0000 0000 0000 0000 000two * 2^(-126)임.<br>
그러나 가장 작은 비정규화 수는 0.0000 0000 0000 0000 0000 001two * 2^(-126) 또는 1.0two * 2^(-149)<br>
2배 정밀도 연산에서는 가장 작은 정규화 수는 1.0 * 2^(-1022)이고 가장 작은 비정규화 수는 1.0 * 2^(-1074)임.<br>
가끔 정규화되지 않은 피연산자가 나타날 수 있다는 가능성은 빠른 부동 소수점 유닛을 만들려는 입장에서 골칫거리였음.<br>
따라서 피연산자가 정규화되지 않은 경우에는 예외를 발생시켜서 소프트웨어로 처리하도록 하는 컴퓨터가 많음.<br>
소프트웨어를 사용한 구현이 완벽하기는 하지만 시간이 너무 많이 소요되므로 이식 가능한 부동 소수점 소프트웨어에서는 비정규화 수를 잘 사용하지 않게 됨.<br>
게다가 프로그래머가 비정규화 수에 대비하지 않는 경우에는 프로그램이 문제를 발생시킬 수 있음.<br>
