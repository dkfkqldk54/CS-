<h1>:green_book: <Computer Orgarnization And Design RISC-V Edition> 정리</h1>

<a href="#1">:pencil2: Chapter1. 컴퓨터 추상화 및 관련 기술</a>
- 컴퓨터 구조 분야의 일곱 가지 위대한 아이디어
- 프로그램 밑의 세계
- 케이스를 열고
- 프로세서와 메모리 생산 기술
- 성능
- 전력 장벽
- 현저한 변화: 단일프로세서에서 멀티프로세서로의 변화
- 오류 및 함정


<h2><a id="1">:pencil2: Chapter1. 컴퓨터 추상화 및 관련 기술</a></h2>

**:pushpin: 컴퓨터 구조 분야의 일곱 가지 위대한 아이디어**

- 설계를 단순화 하는 추상화: 하위 수준의 상세한 사항을 안 보이게 함으로써 상위 수준 모델을 단순화함.<br>
- 자주 생기는 일을 빠르게: 드물게 생기는 일을 최적화하는 것보다 성능 개선에 도움이 됨.<br>
- 병렬성을 통한 성능 개선<br>
- 파이프라이닝을 통한 성능 개선<br>
- 예측을 통한 성능 개선<br>
- 메모리 계층 구조: 최상위 계층에는 가장 빠르고, 가장 작고, 비트당 가격이 제일 비싼 메모리를 사용하고, 최하위 계층에는 느리지만 크고 비트당 가격이 제일 싼 메모리를 사용함.<br>
- 여유분을 이용한 신용도 개선: 모든 물리 소자는 장애가 발생할 수 있으므로, 장애를 감지하고 장애가 난 소자를 대치할 수 있도록 여유분을 준비하면 컴퓨터의 신용도를 개선할 수 있음.<br>

**:pushpin: 프로그램 밑의 세계**

소프트웨어들은 계층적으로 구성됨. 응용 프로그램이 가장 바깥쪽에 위치하며, 여러 가지 시스템 소프트웨어가 하드웨어와 응용 소프트웨어 사이에 존재함.<br>
시스템 소프트웨어는 여러가지가 있으나 대표적으로 운영체제와 컴파일러가 있음.<br>
운영체제는 사용자 프로그램과 하드웨어 간의 인터페이스 역할을 하면서 각종 서비스와 감독 기능을 제공함.<br>
기본적 입출력 작업의 처리, 보조기억장치 및 메모리 할당, 컴퓨터를 동시에 사용하는 여러 응용들 간의 컴퓨터 공유 방법 제공 등 기능이 있음.<br>
오늘날 사용되고 있는 운영체제의 예로는 Windows, Linux, iOS, Android 등이 있음.<br>
컴파일러는 C, C++, Java, Visual Basic 같은 상위 수준 언어로 작성된 프로그램을 하드웨어가 실행할 수 있는 명령어로 번역하는 일을 함.<br>

**상위 수준 언어에서 기계어까지**

기계어는 기수 2인 숫자, 즉 이진수라고 생각함.<br>
각 문자를 이진 자릿수 또는 비트라고 부름.<br>
명령어(instruction)는 컴퓨터 하드웨어가 이해하고 실행하는 명령임.<br>
어셈블러는 기호로 된 명령어(어셈블리 언어)를 이진수 프로그램으로 번역하는 프로그램임.<br>
예를 들어 add A, B라고 쓰면 어셈블러가 이것을 1001010100101110으로 바꿈.<br>
기계가 이해하는 언어는 기계어라고 부름.<br>
어셈블리 언어는 컴퓨터가 실행할 명령어를 한 줄에 하나씩 써야하기 때문에 프로그래머에게 기계식 사고 방식을 강요함.<br>
상위 수준 언어에서 A + B가 있으면 컴파일러는 이것을 번역해서 add A, B와 같은 어셈블리 언어 문장으로 바꿈.<br>

**:pushpin: 케이스를 열고**
 
 모든 컴퓨터의 하드웨어는 데이터 입력, 출력, 처리, 저장 네 가지 기본 기능을 수행함.<br>
 입력장치는 키보드나 마우스와 같이 컴퓨터에 정보를 공급하는 장치임.<br>
 출력장치는 연산의 결과를 사용자나 다른 컴퓨터에 보내주는 장치임.<br>
 컴퓨터의 고전적 구성 요소 다섯 가지는 입력, 출력, 메모리, 데이터패스, 제어 유닛임. 데이터패스와 제어 유닛을 합쳐서 프로세서라고 부르기도 함.<br>
 프로세서는 메모리에서 명령어와 데이터를 읽음.<br>
 입력장치는 메모리에 데이터를 쓰고, 출력장치는 메모리에서 데이터를 읽음.<br>
 제어 유닛은 데이터패스, 메모리, 입력장치, 출력장치의 동작을 결정하는 신호를 내보냄.<br>
 
 **디스플레이**<br>
 
 개인 휴대용 기기들은 얇고 전력 소모가 적은 LCD(Liquid crystal display)를 사용함.<br>
 LCD는 스스로 빛을 내는 대신 통과하는 빛을 제어함.<br>
 전형적인 LCD에는 액체 상태의 막대 모양 분자가 있어서 디스플레이에 들어오는 빛을 굴절시킴.<br>
 빛은 보통 디스플레이 뒤쪽의 광원에서 보내지며, 이보다 흔하지는 않지만 반사광을 이용하는 경우도 있음.<br>
 이 막대들이 보통 때는 꼬인 나선 모양으로 배열되어서 빛을 굴절시키다가 전류를 흘리면 똑바로 퍼져서 빛을 통과시킴.<br>
 90도로 편광된 두 스크린 사이에 액정 물질을 넣기 때문에 빛이 꺽이지 않는 한 통과할 수 없음.<br>
 오늘날 대부분의 LCD는 매 화소 위치마다 작은 트랜지스터를 배치하여 전류를 정밀하게 제어하는 능동 행렬을 사용하므로 더욱 선명한 이미지를 제공함.<br>
 매 화소마다 R-G-B 마스크가 있어서 각 원색의 강도를 결정함. 따라서 컬러 능등 행령 LCD에는 화소마다 3개의 트랜지스터 스위치가 있음.<br>
 화소는 영상을 구성하는 제일 작은 원소를 뜻함.<br>
 각 화상은 화소의 행렬로 구성되며, 이것은 비트맵이라 부르는 비트들의 행렬로 표현됨.<br>
 디스플레이 행렬은 스크린의 크기와 해상도에 따라 1024 * 768에서 2048 * 1536개의 화소로 구성됨.<br>
 컬러 디스플레이는 빛의 삼원색(빨강, 파랑, 초록) 각각마다 8비트씩, 모두 24비트를 사용하여 수백만 가지의 색을 표시할 수 있음.<br>
 그래픽을 지원하는 하드웨어의 중심이 되는 것은 비트맵을 기억하는 프레임 버퍼라고 하는 부분임.<br>
 그래픽 하드웨어는 스크린에 표시될 화상을 프레임 버퍼에 저장하였다가, 기억된 각 화소의 비트 패턴을 재생 속도에 맞추어 그래픽 디스플레이로 보냄.<br>
 
 **터치스크린**<br>
 
 태블릿과 스마트폰은 키보드와 마우스 대신 터치를 감지하는 디스플레이를 사용하고 있음.<br>
 터치스크린을 구현하는 방법 중 하나는 정전용량 감지 기법임.<br>
 유리 같은 절연체 위에 투명한 도체를 코팅하면, 사람이 손을 댔을 때 손에 전기가 통하기 때문에 스크린의 정전기장이 찌그러지면서 정전용량이 변하게 됨.<br>
 
 **상자를 열고**<br>
 
 집적회로는 칩이라고도 부름. 수천만 개의 트랜지스터가 결합된 부품임.<br>
 CPU는 프로세서라고도 부름. 데이터패스와 제어 유닛으로 구성된 컴퓨터의 핵심 부분임. 숫자를 더하거나 검사하고, 입출력장치에 신호를 보내 활성화하는 일을 함.<br>
 데이터패스는 산술 연산을 수행하는 프로세서의 구성 요소임.<br>
 제어 유닛은 프로그램의 명령어에 따라 데이터패스, 메모리, 입출력장치에 지시를 하는 프로세서 구성 요소임.<br>
 메모리는 실행 중인 프로그램과 프로그램 실행에 필요한 데이터의 저장소임. 메모리는 DRAM 칩으로 구성되어 있음.<br>
 DRAM(Dynamic Random Access Memory)은 집적회로로 만든 메모리의 일종임. 어떤 위치든지 임의로 접근할 수 있음. 접근 시간은 50ns정도임.<br>
 DRAM 여러 개를 한데 묶어서 프로그램의 명령어와 데이터를 기억하는데 사용함.<br>
 DRAM에서 RAM은 자기 테이프 같은 순차 접근 메모리와는 반대로 메모리의 어떤 부분을 읽든지 같은 시간이 걸린다는 것을 의미함.<br>
 프로세서 내부에는 또 다른 종류의 메모리가 있는데 이것을 캐시 메모리라고함.<br>
 캐시 메모리는 DRAM의 버퍼 역할을 하는 작고 빠른 메모리임.<br>
 캐시는 SRAM(Static Random Access Memory)이라는 메모리 기술을 이용함. SRAM은 DRAM보다 빠르지만 집적도가 낮아서 가격이 비쌈.<br>
 SRAM과 DRAM은 메모리 계층구조의 두 계층을 구성함.<br>
 소프트웨어는 하드웨어와 어휘를 통해 통신함.<br>
 어휘를 구성하는 단어들을 명령어라고 하고, 어휘 자체는 명령어 지밥 구조(Instruction Set Architecture) 또는 단순히 구조라고 함.
 응용 프로그래머에게 제공되는 기본 명령어 집합과 운영체제 인터페이스를 합쳐서 ABI(Application Binary Interface)라고 함.<br>
 
 **데이터의 안전한 저장소**<br>
 
메인 메모리: 휘발성 메모리라고도 함. DRAM과 같이 전원이 공급되는 동안만 데이터를 기억하는 기억장치임.<br>
보조기억장치: 비휘발성 메모리라고도 함. 전원 공급이 끊어져도 데이터를 계속 기억하는 기억장치로, 다음 실행 때까지 프로그램을 저장하는 데 사용됨. 보조기억장치는 메모리 계층구조에서 메인 메모리보다 한 단계 아래 계층에 해당함.<br>
 DRAM이 메인 메모리의 주종을 이루고 있으며, 자기 디스크는 그 전부터 보조기억장치의 주종이 되었음.<br>
 개인 휴대용 기기는 크기와 모양의 제약 때문에 자기 디스크 대신 비휘발성 반도체 메모리인 플래시 메모리를 사용함.<br>
 플래시 메모리는 DRAM보다 느리지만, DRAM보다 훨씬 싸고 비휘발성이라는 장점이 있음.<br>
 디스크보다 비트당 단가는 비싸지만, 작고 튼튼하며 전력 소모가 적고 훨씬 소용량으로 생산될 수 있음.<br>
 그래서 PMD(Persistent Memory Device, 영구 저장이 가능한 비휘발성 메모리를 의미)의 표준 보조기억장치로 사용됨. 하지만 DRAM이나 자기 디스크와 달리 플래시 메모리는 10만번 내지 100만번 쓰기를 한 후에는 못 쓰게 됨.<br>
 
 **컴퓨터 간의 통신**<br>
 
 네트워크로 컴퓨터를 연결했을 때의 장점은 통신, 자원 공유, 원격 접근 등이 있음.<br>
 네트워크 중에서 가장 널리 알려진 것은 이더넷(Ethernet)임.<br>
 이더넷으로 연결할 수 있는 거리는 대략 1km 정도이고, 초당 100Gb를 전송할 수 있음.<br>
 한 건물의 같은 층에 있는 컴퓨터들을 연결하는데 유용한 근거리 네트워크(Local Area Network, LAN)의 일종임.<br>
 라우터 서비스와 보안을 제공하는 스위치를 사용하면 LAN들을 서로 연결할 수 있음.<br>
 원거리 네트워크(Wide Area Network, WAN)는 여러 대륙을 연결하여 웹(world Wide Web)을 지원하고 있는 인터넷의 근간을 이룸.<br>

**:pushpin: 프로세서와 메모리 생산 기술**
 
 집적회로 칩의 생산은 모래의 구성 성분인 실리콘에서부터 출발함.<br>
 실리콘은 전기가 통하기는 하는데 완전 잘 통하는 것은 아니어서 반도체임.<br>
 특수한 화학적 처리를 거쳐 불순물을 첨가하면 실리콘의 작은 부분을 세 가지 중 하나로 바꿀 수 있음.<br>
 전기 양도체(초소형 구리나 알루미늄 전선), 전기 절연체(플라스틱 피복이나 유리 등), 조건에 따라 도체가 되기도 하고 절연체가 되기도 하는 물질(스위치)<br>
 공정은 실리콘 결정 괴(silicon crystal ingot)에서부터 시작됨.<br>
 실리콘 괴의 직경은 8~12인치, 길이는 12~24인치 정도임.<br>
 이 덩어리를 0.1인치 이하의 두께로 얇게 잘라 웨이퍼를 만듦.<br>
 웨이퍼는 화학 물질을 첨가하여 부분 부분을 트랜지스터, 도체, 절연체로 바꾸는 일련의 공정을 거치게 됨.<br>
 빈 웨이퍼에는 패턴이 새겨지는데, 이를 웨이퍼 검사기로 검사해서 불량 부분에 표시함.<br>
 웨이퍼 자체에 미세한 흠집이 있었거나 여러 공정 중에 어느 한 부분에서라도 흠집이 생기면 웨이퍼의 그 부분은 못 쓰게 되는데, 이러한 결함 때문에 완벽한 웨이퍼를 만드는 건 거의 불가능함.<br>
 불완전성에 대처하기 위해 한 웨이퍼에 독립적인 컴포넌트를 여러 개 만들고, 웨이퍼를 컴포넌트별로 자르는데 이것을 다이 또는 칩이라고 함.<br>
 여러 조각으로 나누면 웨이퍼에 결함이 생겼을 때 웨이퍼 전체를 버리는 대신 해당 다이만 버리면 됨. 이 개념을 수율로 계량화 할 수 있음.<br>
 한 웨이퍼에서 20개의 다이가 만들어지고 그 중 17개만이 검사를 통과하면 수율은 85%임.<br>
 다이 크기가 커지면 웨이퍼에 넣을 수 있는 다이가 적어지고 수율이 떨어지므로 집적회로 가격이 급속히 증가함.<br>
 차세대 프로세스를 이용해서 트랜지스터와 연결선의 크기를 줄임으로써 큰 다이를 축소시켜 원가 절감을 꾀하기도 함.<br>
 이렇게 하면 수율과 웨이퍼당 다이 개수가 개선됨.<br>
 다이가 10 nm 공정을 사용하고 있다는 말은 가장 작은 트랜지스터의 크기가 10nm라는 뜻임.<br>
 하지만 트랜지스터는 실제 최소 배선폭보다 더 작은 것이 보통임.<br>
 최소 배선폭이란 최종 생산된 트랜지스터의 크기가 아니라 마스크에 그려진 크기를 뜻하는 것임.<br>
 결함이 없는 다이는 패키지의 입출력 핀과 연결하는데 이 과정을 본딩이라고 함.<br>
 납품하기 전에는 다시 한번 검사를 거침.<br>
 
 **집적회로 가격**<br>
 
 다이 원가 = 웨이퍼당 가격 / (웨이퍼당 다이의 수 * 수율)<br>
 웨이퍼당 다이의 수 = 웨이퍼의 면적 / 다이의 면적<br>
 수율 = 1 / (( 1 + (면적당 결함의 수 * 다이 면적 ) ) ^ n)<br>
 n은 공정의 수인데, 공정이 많을 수록 수율은 떨어짐.<br>
 
**:pushpin: 성능**
 
 성능x = 1 / 실행시간x<br>
 성능x > 성능y는 1 / 실행시간x > 1 / 실행시간y랑 같으므로 실행시간y > 실행시간x와 같은 말임.<br>
 X가 Y보다 n배 빠르다면 성능x / 성능y = 실행시간y / 실행시간x = n임.<br>
 
 **성능의 측정**<br>
 
 보통 성능을 측정하기 위해 사용하는 시간은 벽시계 시간, 응답시간, 경과시간 등이 있음.<br>
 이것은 한 작업을 끝내는 데 필요한 전체 시간을 뜻하는 것으로 디스크 접근, 메모리 접근, 입출력 작업, 운영체제 오버헤드 등 모든 시간을 다 더한 것임.<br>
 컴퓨터를 공유하는 경우, 프로세서 하나가 여러 프로그램을 동시에 실행하는 경우가 많이 있음.<br>
 그러므로 경과시간과 구분해서 프로세서가 순수하게 이 프로그램을 실행하기 위해 소비한 시간을 계산할 필요가 있음.<br>
 이 시간을 CPU 실행시간 또는 CPU 시간이라고 함.<br>
 CPU 시간은 실제로 사용자 프로그램 실행에 소요된 사용자 CPU 시간과 운영체제가 이 프로그램을 위한 작업을 수행하기 위해 소비한 시스템 CPU 시간으로 다시 나눌 수 있음.<br>
 그러나 운영체제의 각 작업이 어떤 프로그램을 위해서 수행되고 있는가를 명확히 가려내는 것이 어렵고 운영체제 간의 기능 차이도 있기 때문에 시스템 CPU 시간과 사용자 CPU 시간을 정확히 구하는 것은 어려움.<br>
 다른 부하가 없는 시스템에서의 경과시간으로 계산한 것을 시스템 성능, 사용자 CPU 시간으로 계산한 것을 CPU 성능이라고 부름.<br>
 거의 모든 컴퓨터는 하드웨어 이벤트가 발생하는 시점을 결정하는 클럭을 이용하여 만들어짐.<br>
 이 클럭의 시간 간격을 클럭 사이클이라 함.<br>
 클럭 주기는 한 클럭 사이클에 걸리는 시간(250ps 등)이나 클럭 속도(4 GHz 등)로 표시함.<br>
 클럭 속도는 클럭 주기의 역수임.<br>
 
 **CPU 성능과 성능 인자**<br>
 
 프로그램의 CPU 실행 시간 = 프로그램의 CPU 클럭 사이클 수 * 클럭 사이클 시간<br>
 프로그램의 CPU 실행 시간 = 프로그램의 CPU 클럭 사이클 수 / 클럭 속도<br>
 
 **명령어 성능**<br>
 
 CPU 클럭 사이클 수 = 명령어 수 * 명령어당 평균 클럭 사이클 수<br>
 명령어당 클럭 사이클 수(clock cycles per instruction)은 CPI로 줄여 쓰기도 함.<br>
 명령어마다 실행시간이 다르므로 CPI는 프로그램이 실행한 모든 명령어에 대해 평균한 값을 사용함.<br>
 명령어 집합 구조가 같으면 프로그램에 필요한 명령어 수가 같으므로, CPI는 서로 다른 구현을 비교하는 한 가지 기준이 될 수 있음.<br>
 
 **고전적인 CPU 성능식**<br>
 
 CPU 시간 = 명령어 개수 * CPI * 클럭 사이클 시간<br>
 CPU 시간 = 명령어 개수 * CPI / 클럭 속도<br>
CPU 실행시간은 실제 프로그램을 실행시켜서 얻을 수 있고, 클럭 사이클 시간은 보통 컴퓨터의 하드웨어 매뉴얼에 기록되어 있음.<br>
 그러나 명령어 개수와 CPI는 구하기가 어려움.<br>
 물론 클럭 속도와 CPU 실행시간을 알 때, 명령어 개수나 CPI 중 하나를 알면 다른 하나는 계산으로 구할 수 있음.<br>
 명령어 개수는 실행 과정을 추적하는 소프트웨어 도구나 컴퓨터 구조의 시뮬레이터를 이용해서 측정할 수 있음.<br>
 그 외에 하드에어 카운터를 사용하면 실행 명령어 수나 평균 CPI, 심지어는 성능 저하의 원인까지 찾아낼 수 있음.<br>
 명령어 개수는 구조에 따라서 결정될 뿐 구현 방법과는 상관이 없으므로 자세한 구현 내용은 몰라도 구할 수 있음.<br>
 그러나 CPI는 프로그램 실행에 사용되는 명령어 배합뿐 아니라 메모리 시스템과 프로세서 구조를 포함하는 여러 가지 컴퓨터 세부 설계에 따라 달라짐.<br>
 따라서 CPI는 명령어 집합이 같더라도 구현 방식에 따라서 달라질 뿐 아니라 응용 프로그램에 따라서도 달라짐.<br>
 CPU 성능식의 인자에 영향을 미치는 요소는 알고리즘, 프로그래밍 언어, 컴파일러, 명령어 집합 구조 등이 있음.<br>
 CPI의 역수인 IPC(Instructions per clock cycle, 클럭 사이클당 명령어 수)도 사용함.<br>
 전통적으로 클럭 사이클 시간은 고정값을 사용해 왔지만, 오늘날의 프로세서는 에너지를 절약하거나 일시적으로 성능을 높이기 위해서 클럭 속도를 변경시키기도 함.<br>
 따라서 프로그램에 대한 평균 클럭 속도를 사용할 필요가 있음.<br>
 
**:pushpin: 전력 장벽**
  
**:pushpin: 현저한 변화: 단일프로세서에서 멀티프로세서로의 변화**

**:pushpin: 오류 및 함정**
  
  
 
