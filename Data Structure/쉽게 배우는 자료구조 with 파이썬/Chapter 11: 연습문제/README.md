<h2>:pencil2: Exercises</h2>

**:pushpin: 1번**

이진 검색 트리에서 검색 시간은 트리의 깊이에 비례한다. 최악의 경우는 노드가 한쪽 방향으로만 매달려서 트리의 깊이와 노드의 개수가 같은 경우이다. 노드의 개수가 n개일 때 점근적 검색 시간은 O(n)이 된다. 반면 최선의 경우는 포화이진트리를 형성하는 경우이다. 노드의 개수가 n개일 때, 트리의 깊이는 log2(n+1)이 된다. 따라서 점근적 검색 시간은 O(log n)이 된다.

**:pushpin: 2번**

삽입: 만약 자식 노드가 1개만 달려있다면 삽입으로 인한 불균형이 일어났던 것이라고 추측할 수 있지만, 자식 노드가 2개가 달려있기 때문에 삽입으로 인한 불균형이라고 볼 수는 없다. 1개의 자식 노드가 달려있는 시점에서 이미 AVL 트리의 특성이 깨졌기 때문이다.<br>
삭제: 지금은 좌서브 트리에 노드가 없는데, 이를 제거했기 때문에 AVL 트리의 특성이 깨졌다고 볼 수 있다.<br>
따라서 위 사례는 삽입 작업을 한 직후이다.<br>

**:pushpin: 3번**

삽입: 노드 17을 삽입한 경우 AVL 트리의 특성을 깰 수 있다.<br>
삭제: 노드 55의 자식 노드를 삭제한 경우 AVL 트리의 특성을 깰 수 있다.<br>
따라서 삽입, 삭제 둘 다 가능하다.<br>

**:pushpin: 4번**

3번 트리는 LR 사례이다. 따라서 노드 10을 기준으로 좌회전을 하고, 노드 40을 기준으로 우회전을 하면 된다.
루트 노드: [20]
부모 노드1: [10] 
부모 노드2: [40]
부모 노드1의 자식 노드: [15,17]
부모 노드2의 자식 노드: [55]

**:pushpin: 5번**

LR과 RL이다.

**:pushpin: 6번**

틀린 주장이다. 수선 이후에도 트리의 높이는 유지될 수 있다.

**:pushpin: 7번**

예, 그림 11-18의 경우 세 번의 좌회전 끝에 균형이 맞게 된 케이스임.

**:pushpin: 8번**

노드 6 왼쪽에 레드 색상의 노드 7을 삽입하면 별도로 균형을 맞추지 않아도 레드 블랙 트리의 특성을 만족한다.

**:pushpin: 9번**

case2가 일어난 뒤에는 case1만 연쇄적으로 일어날 수 있으니, 이번 풀이에서는 case1만 일어난다고 가정하고 설명하겠다. case1에서 x가(x는 case1 상에서 검은색에서 빨간색이 되는 말단 노드임) 검은색일 때를 문제가 발생하기 전 '초기 상태'라고 정의하겠다. 이 초기 상태의 트리를 3개 쌓아올리겠다. p3은 위에 있는 트리의 x가 되고, p5는 또 그 위에 있는 트리의 x가 되는 식이다. 맨 꼭대기 노드에는 루트 노드인 p7이 있을 것이다. 맨 아래에 있는 트리의 x노드를 빨간색으로 바꾸게 되면 재귀적으로 수선이 일어난다. p에서 p7까지의 수선 과정에서 생기는 색의 변화는 다음과 같다.<br>

p p2 p3 p4 p5 p6 p7<br>
B R &nbsp;&nbsp;B &nbsp;&nbsp;R &nbsp;&nbsp;B &nbsp;&nbsp;R &nbsp;&nbsp;B<br>
R R &nbsp;&nbsp;B &nbsp;&nbsp;R &nbsp;&nbsp;B &nbsp;&nbsp;R &nbsp;&nbsp;B<br>
R B &nbsp;&nbsp;R &nbsp;&nbsp;R &nbsp;&nbsp;B &nbsp;&nbsp;R &nbsp;&nbsp;B<br>
R B &nbsp;&nbsp;R &nbsp;&nbsp;B &nbsp;&nbsp;R &nbsp;&nbsp;R &nbsp;&nbsp;B<br>
R B &nbsp;&nbsp;R &nbsp;&nbsp;B &nbsp;&nbsp;R &nbsp;&nbsp;B &nbsp;&nbsp;R<br>
R B &nbsp;&nbsp;R &nbsp;&nbsp;B &nbsp;&nbsp;R &nbsp;&nbsp;B &nbsp;&nbsp;B<br>

**:pushpin: 10번**

18을 넣어서 오버플로우가 발생했다. 왼쪽 형제 노드에 공간 여유가 있으니 15를 부모 노드에 넘긴 후, 부모 노드에 있는 13을 왼쪽 형제 노드로 넘긴다.

**:pushpin: 11번**

16을 넣어서 오버플로우가 발생했다. 양쪽 형제 노드에 공간 여유가 없으니 19를 부모 노드에 넘기고 [16,17,18], [20,23]으로 분기한다.

**:pushpin: 12번**

22의 직후 노드인 24와 자리를 바꾼다. 리프 노드에 있는 22를 삭제한다.

**:pushpin: 13번**

19의 직후 노드인 20과 자리를 바꾼다. 리프 노드에 있는 19를 삭제한다. <br>
리프 노드에서 언더플로우가 발생한다. 양쪽 형제 노드에서 키를 넘겨줄 여력이 없다. 부모 노드의 24와 형제 노드에 있는 25, 26을 함께 결합한다.<br>
20이 들어있는 부모 노드에서 언더 플로우가 발생한다. 형제 노드에서 키를 건네줄 여력이 없으므로 형제 노드와 루트 노드를 결합한다.<br>

**:pushpin: 14번**

삭제할 원소를 X, X의 직후 원소를 s라 하자. 이 때 X가 있는 노드의 깊이는 n이며, 트리의 깊이는 m(n<m)이라고 하자.<br>

**의문 1: X보다 s가 높은 곳에 있으면 안 되는가?**

s가 X보다 높은 곳에 있다고 가정하자. X는 자식 노드를 가져야 하므로 X보다 큰 원소를 가지는 자식 노드가 있어야 한다. X보다 큰 원소를 가지는 자식 노드 중 가장 왼쪽에 있는 원소를 o라 하면 X<o이다. 그런데 o은 s의 왼쪽으로 분기되어 온 노드에서 분기되었기 때문에 s보다 작을 수 밖에 없다. 따라서 o<s이다. 이에 따라 X<o<s인데 이는 s가 X의 직후 원소라는 가정과 모순된다.<br>

**-> 증명 1: s는 X보다 높은 곳에 있을 수 없다.**

**의문 2: X의 오른쪽에 s가 있으면 안 되는가? 즉 같은 높이에 있으면 안 되는가?**

X의 오른쪽에 s가 있다고 가정해보자. 즉 s가 같은 깊이에 있다고 가정한다. 이 때, s가 같은 노드에 있는지, 형제 노드에 있는지는 중요하지 않다. X와 s 사이에서 생긴 자식 노드에 들어가는 원소는 X보다 크고 s보다 작아야 한다. 이를 o라 하겠다. 이렇게 될 경우 X<o<s의 관계가 성립되는데 이는 s가 X의 직후 원소라는 가정과 모순된다.

**-> 증명 2: s는 X와 같은 높이에 있을 수 없다.**<br>
**-> 증명 3: 증명 1과 증명 2에 의해 s는 X보다 낮은 높이에 위치해야 한다.**<br>

**(베이스 케이스) 증명 3에 의해 m = n+1일 때 성립한다.**<br>

**(귀납적 가정) m = k(k>n+1)일 때 리프 노드에 X의 직후 원소인 s가 존재한다고 가정하자.**<br>

**(귀납적 전개) m = k +1일 때도 리프 노드에 X의 직후 원소인 s가 존재한다는 것을 증명하면 된다.**<br>

X의 오른쪽에 있는 원소를 Xright라 하자. Xright는 증명 2에 의해 x의 직후 원소 s일 수는 없지만 x보다는 크다. 따라서 x<s<Xright 관계가 성립한다.<br>

X의 오른쪽 자식 노드에 있는 원소들 중 가장 작은 원소를 Xn+1이라 하자.<br>
Xn+1의 왼쪽 자식 노드에 있는 원소들 중 가장 작은 원소를 Xn+2이라 하자.<br>
...<br>
Xk-1의 왼쪽 자식 노드에 있는 원소들 중 가장 작은 원소를 Xk라고 하자.<br>
Xk의 왼쪽 자식 노드에 있는 원소들 중 가장 작은 원소를 Xk+1이라고 하자.<br>

따라서 X<Xk+1<Xk<Xk-1< ... < Xn+1<Xright가 성립한다.<br>

s는 Xk보다는 작고 X보다는 커야한다. B트리 안에서 이 조건을 만족시킬 수 있는 원소는 Xk+1밖에 없다. 그러므로 s=Xk+1이며, m=k+1일 때 X의 직후 원소인 s는 리프 노드에 위치한다.

**:pushpin: 15번**

부모 노드의 페이지: 4바이트<br>
자식 노드의 페이지: (k+1) * 4바이트<br>
키와 페이지: k * (20 +4) 바이트<br>
필요한 바이트: 28 * k + 8바이트<br>
따라서 최대 292개의 키를 가질 수 있다.

**:pushpin: 16번**

내부 노드에 있는 키의 수를 n(n<=k)라고 하면, 리프 노드에 있는 키의 수는 최소 (n+1)*[k/2]개, 최대 (n+1)*k개이다.

**:pushpin: 17번**

언더플로우가 일어난 노드는 [k/2]-1개의 키를 가지고 있음.<br>
언더플로우로 병합이 일어나기 위해서는 형제 노드 중 키를 하나 내놓을 수 있는 여분을 가진 노드가 없어야 함. 따라서 형제 노드가 가지고 있는 키의 수는 [k/2]개임.<br>
부모 노드로부터 키를 1개 가져옴.<br>
따라서 병합된 노드의 키의 수는 [k/2] + [k/2]개임.<br>
이는 k보다 작거나 같기 때문에 오버플로우가 발생할 수 없음.<br>

**:pushpin: 18번**

4층

**:pushpin: 19번**
