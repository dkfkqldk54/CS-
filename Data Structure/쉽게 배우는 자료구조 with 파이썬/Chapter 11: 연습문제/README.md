<h2>:pencil2: Exercises</h2>

**:pushpin: 1번**

이진 검색 트리에서 검색 시간은 트리의 깊이에 비례한다. 최악의 경우는 노드가 한쪽 방향으로만 매달려서 트리의 깊이와 노드의 개수가 같은 경우이다. 노드의 개수가 n개일 때 점근적 검색 시간은 O(n)이 된다. 반면 최선의 경우는 포화이진트리를 형성하는 경우이다. 노드의 개수가 n개일 때, 트리의 깊이는 log2(n+1)이 된다. 따라서 점근적 검색 시간은 O(log n)이 된다.

**:pushpin: 2번**

삽입: 만약 자식 노드가 1개만 달려있다면 삽입으로 인한 불균형이 일어났던 것이라고 추측할 수 있지만, 자식 노드가 2개가 달려있기 때문에 삽입으로 인한 불균형이라고 볼 수는 없다. 1개의 자식 노드가 달려있는 시점에서 이미 AVL 트리의 특성이 깨졌기 때문이다.<br>
삭제: 지금은 좌서브 트리에 노드가 없는데, 이를 제거했기 때문에 AVL 트리의 특성이 깨졌다고 볼 수 있다.<br>
따라서 위 사례는 삽입 작업을 한 직후이다.<br>

**:pushpin: 3번**

삽입: 노드 17을 삽입한 경우 AVL 트리의 특성을 깰 수 있다.<br>
삭제: 노드 55의 자식 노드를 삭제한 경우 AVL 트리의 특성을 깰 수 있다.<br>
따라서 삽입, 삭제 둘 다 가능하다.<br>

**:pushpin: 4번**

3번 트리는 LR 사례이다. 따라서 노드 10을 기준으로 좌회전을 하고, 노드 40을 기준으로 우회전을 하면 된다.
루트 노드: [20]
부모 노드1: [10] 
부모 노드2: [40]
부모 노드1의 자식 노드: [15,17]
부모 노드2의 자식 노드: [55]

**:pushpin: 5번**

LR과 RL이다.

**:pushpin: 6번**

틀린 주장이다. 수선 이후에도 트리의 높이는 유지될 수 있다.

**:pushpin: 7번**

**:pushpin: 8번**

노드 6 왼쪽에 레드 색상의 노드 7을 삽입하면 별도로 균형을 맞추지 않아도 레드 블랙 트리의 특성을 만족한다.

**:pushpin: 9번**

**:pushpin: 10번**

18을 넣어서 오버플로우가 발생했다. 왼쪽 형제 노드에 공간 여유가 있으니 15를 부모 노드에 넘긴 후, 부모 노드에 있는 13을 왼쪽 형제 노드로 넘긴다.

**:pushpin: 11번**

16을 넣어서 오버플로우가 발생했다. 양쪽 형제 노드에 공간 여유가 없으니 19를 부모 노드에 넘기고 [16,17,18], [20,23]으로 분기한다.

**:pushpin: 12번**

22의 직후 노드인 24와 자리를 바꾼다. 리프 노드에 있는 22를 삭제한다.

**:pushpin: 13번**

19의 직후 노드인 20과 자리를 바꾼다. 리프 노드에 있는 19를 삭제한다. <br>
리프 노드에서 언더플로우가 발생한다. 양쪽 형제 노드에서 키를 넘겨줄 여력이 없다. 부모 노드의 24와 형제 노드에 있는 25, 26을 함께 결합한다.<br>
20이 들어있는 부모 노드에서 언더 플로우가 발생한다. 형제 노드에서 키를 건네줄 여력이 없으므로 형제 노드와 루트 노드를 결합한다.<br>

**:pushpin: 14번**

**:pushpin: 15번**

부모 노드의 페이지: 4바이트<br>
자식 노드의 페이지: (k+1) * 4바이트<br>
키와 페이지: k * (20 +4) 바이트<br>
필요한 바이트: 28 * k + 8바이트<br>
따라서 최대 292개의 키를 가질 수 있다.

**:pushpin: 16번**

**:pushpin: 17번**

**:pushpin: 18번**

**:pushpin: 19번**
